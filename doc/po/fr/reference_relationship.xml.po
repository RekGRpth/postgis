# SOME DESCRIPTIVE TITLE.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: https://bugs.kde.org\n"
"POT-Creation-Date: 2023-07-09 16:49+0000\n"
"PO-Revision-Date: 2023-05-25 11:08+0000\n"
"Last-Translator: Vincent Bre <vincent.bre@oslandia.com>\n"
"Language-Team: French <https://weblate.osgeo.org/projects/postgis/"
"reference_relationshipxml/fr/>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=n > 1;\n"
"X-Generator: Weblate 4.16.4\n"

#. Tag: para
#: reference_relationship.xml:5
#, no-c-format
msgid "These functions determine spatial relationships between geometries."
msgstr ""
"Ces fonctions déterminent les relations spatiales entre les géométries."

#. Tag: title
#: reference_relationship.xml:8
#, no-c-format
msgid "Spatial Relationships"
msgstr "Relations spatiales"

#. Tag: title
#: reference_relationship.xml:11
#, no-c-format
msgid "Topological Relationships"
msgstr "Relations topologiques"

#. Tag: refname
#: reference_relationship.xml:15
#, no-c-format
msgid "ST_3DIntersects"
msgstr "ST_3DIntersects"

#. Tag: refpurpose
#: reference_relationship.xml:17
#, no-c-format
msgid ""
"Tests if two geometries spatially intersect in 3D - only for points, "
"linestrings, polygons, polyhedral surface (area)"
msgstr ""
"Teste si deux géométries se croisent dans l'espace en 3D - uniquement pour "
"les points, les lignes, les polygones, les surfaces polyédriques (aire)"

#. Tag: funcprototype
#: reference_relationship.xml:23
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_3DIntersects</function></funcdef> <paramdef> "
"<type>geometry</type> <parameter>geomA</parameter> </paramdef> <paramdef> "
"<type>geometry</type> <parameter>geomB</parameter> </paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_3DIntersects</function></funcdef> <paramdef> "
"<type>geometry</type> <parameter>geomA</parameter> </paramdef> <paramdef> "
"<type>geometry</type> <parameter>geomB</parameter> </paramdef>"

#. Tag: title
#: reference_relationship.xml:37 reference_relationship.xml:89
#: reference_relationship.xml:285 reference_relationship.xml:366
#: reference_relationship.xml:445 reference_relationship.xml:521
#: reference_relationship.xml:681 reference_relationship.xml:743
#: reference_relationship.xml:817 reference_relationship.xml:897
#: reference_relationship.xml:1004 reference_relationship.xml:1047
#: reference_relationship.xml:1190 reference_relationship.xml:1342
#: reference_relationship.xml:1398 reference_relationship.xml:1536
#: reference_relationship.xml:1635 reference_relationship.xml:1696
#: reference_relationship.xml:1752 reference_relationship.xml:1817
#: reference_relationship.xml:1882
#, no-c-format
msgid "Description"
msgstr "Description"

#. Tag: para
#: reference_relationship.xml:38
#, no-c-format
msgid ""
"Overlaps, Touches, Within all imply spatial intersection. If any of the "
"aforementioned returns true, then the geometries also spatially intersect. "
"Disjoint implies false for spatial intersection."
msgstr ""
"Overlaps, Touches, Within impliquent tous une intersection spatiale. Si l'un "
"des éléments susmentionnés renvoie un résultat positif, les géométries se "
"recoupent également dans l'espace. Disjoint implique faux pour "
"l'intersection spatiale."

#. Tag: para
#: reference_relationship.xml:42 reference_relationship.xml:561
#: reference_relationship.xml:842 reference_relationship.xml:1644
#: reference_relationship.xml:1704 reference_relationship.xml:1760
#, no-c-format
msgid "&index_aware;"
msgstr "&index_aware;"

#. Tag: para
#: reference_relationship.xml:44
#, no-c-format
msgid "Changed: 3.0.0 SFCGAL backend removed, GEOS backend supports TINs."
msgstr ""
"Modifié : 3.0.0 SFCGAL backend supprimé, GEOS backend supporte les TINs."

#. Tag: para
#: reference_relationship.xml:45 reference_relationship.xml:1355
#: reference_relationship.xml:1651 reference_relationship.xml:1706
#, no-c-format
msgid "Availability: 2.0.0"
msgstr "Disponibilité : 2.0.0"

#. Tag: para
#: reference_relationship.xml:47 reference_relationship.xml:1646
#: reference_relationship.xml:1707
#, no-c-format
msgid "&Z_support;"
msgstr "&Z_support;"

#. Tag: para
#: reference_relationship.xml:49 reference_relationship.xml:1648
#: reference_relationship.xml:1709
#, no-c-format
msgid "&P_support;"
msgstr "&P_support;"

#. Tag: para
#: reference_relationship.xml:50 reference_relationship.xml:863
#, no-c-format
msgid "&T_support;"
msgstr "&T_support;"

#. Tag: para
#: reference_relationship.xml:51
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM IEC 13249-3: 5.1"
msgstr "&sqlmm_compliant; SQL-MM IEC 13249-3: 5.1"

#. Tag: title
#: reference_relationship.xml:54 reference_relationship.xml:866
#, no-c-format
msgid "Geometry Examples"
msgstr "Exemples de géométrie"

#. Tag: programlisting
#: reference_relationship.xml:55
#, no-c-format
msgid ""
"SELECT ST_3DIntersects(pt, line), ST_Intersects(pt, line)\n"
"  FROM (SELECT 'POINT(0 0 2)'::geometry As pt, 'LINESTRING (0 0 1, 0 2 3)'::"
"geometry As line) As foo;\n"
" st_3dintersects | st_intersects\n"
"-----------------+---------------\n"
" f               | t\n"
"(1 row)"
msgstr ""
"SELECT ST_3DIntersects(pt, line), ST_Intersects(pt, line)\n"
"  FROM (SELECT 'POINT(0 0 2)'::geometry As pt, 'LINESTRING (0 0 1, 0 2 3)'::"
"geometry As line) As foo;\n"
" st_3dintersects | st_intersects\n"
"-----------------+---------------\n"
" f               | t\n"
"(1 row)"

#. Tag: title
#: reference_relationship.xml:58
#, no-c-format
msgid "TIN Examples"
msgstr "Exemples TIN"

#. Tag: programlisting
#: reference_relationship.xml:59
#, no-c-format
msgid ""
"SELECT ST_3DIntersects('TIN(((0 0 0,1 0 0,0 1 0,0 0 0)))'::geometry, "
"'POINT(.1 .1 0)'::geometry);\n"
" st_3dintersects\n"
"-----------------\n"
" t"
msgstr ""
"SELECT ST_3DIntersects('TIN(((0 0 0,1 0 0,0 1 0,0 0 0)))'::geometry, "
"'POINT(.1 .1 0)'::geometry);\n"
" st_3dintersects\n"
"-----------------\n"
" t"

#. Tag: title
#: reference_relationship.xml:62 reference_relationship.xml:258
#: reference_relationship.xml:329 reference_relationship.xml:409
#: reference_relationship.xml:496 reference_relationship.xml:653
#: reference_relationship.xml:720 reference_relationship.xml:776
#: reference_relationship.xml:874 reference_relationship.xml:981
#: reference_relationship.xml:1024 reference_relationship.xml:1149
#: reference_relationship.xml:1310 reference_relationship.xml:1370
#: reference_relationship.xml:1600 reference_relationship.xml:1661
#: reference_relationship.xml:1719 reference_relationship.xml:1771
#: reference_relationship.xml:1856 reference_relationship.xml:1903
#, no-c-format
msgid "See Also"
msgstr "Voir aussi"

#. Tag: refname
#: reference_relationship.xml:69
#, no-c-format
msgid "ST_Contains"
msgstr "ST_Contains"

#. Tag: refpurpose
#: reference_relationship.xml:71
#, no-c-format
msgid ""
"Tests if every point of B lies in A, and their interiors have a point in "
"common"
msgstr ""
"Tests si chaque point de B est situé dans A, et que leurs intérieurs ont un "
"point commun"

#. Tag: funcprototype
#: reference_relationship.xml:76
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_Contains</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_Contains</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef>"

#. Tag: para
#: reference_relationship.xml:91
#, no-c-format
msgid ""
"Returns TRUE if geometry A contains geometry B. A contains B if and only if "
"all points of B lie inside (i.e. in the interior or boundary of) A (or "
"equivalently, no points of B lie in the exterior of A), and the interiors of "
"A and B have at least one point in common."
msgstr ""
"Renvoie TRUE si la géométrie A contient la géométrie B. A contient B si et "
"seulement si tous les points de B se trouvent à l'intérieur (c'est-à-dire à "
"l'intérieur ou à la limite) de A (ou, de manière équivalente, si aucun point "
"de B ne se trouve à l'extérieur de A), et si les intérieurs de A et de B ont "
"au moins un point en commun."

#. Tag: para
#: reference_relationship.xml:97
#, no-c-format
msgid ""
"In mathematical terms: <emphasis>ST_Contains(A, B) ⇔ (A ⋂ B = B) ∧ (Int(A) ⋂ "
"Int(B) ≠ ∅) </emphasis>"
msgstr ""

#. Tag: para
#: reference_relationship.xml:100
#, no-c-format
msgid ""
"The contains relationship is reflexive: every geometry contains itself. (In "
"contrast, in the <xref linkend=\"ST_ContainsProperly\"/> predicate a "
"geometry does <emphasis>not</emphasis> properly contain itself.) The "
"relationship is antisymmetric: if <code>ST_Contains(A,B) = true</code> and "
"<code>ST_Contains(B,A) = true</code>, then the two geometries must be "
"topologically equal (<code>ST_Equals(A,B) = true</code>)."
msgstr ""
"La relation contains est réflexive : toute géométrie se contient elle-même. "
"(En revanche, dans le prédicat <xref linkend=\"ST_ContainsProperly\"/>, une "
"géométrie ne se contient<emphasis>pas</emphasis> elle-même correctement). La "
"relation est antisymétrique : si <code>ST_Contains(A,B) = true</code> et "
"<code>ST_Contains(B,A) = true</code>, alors les deux géométries doivent être "
"topologiquement égales (<code>ST_Equals(A,B) = true</code>)."

#. Tag: para
#: reference_relationship.xml:107
#, no-c-format
msgid ""
"ST_Contains is the converse of <xref linkend=\"ST_Within\"/>. So, "
"<code>ST_Contains(A,B) = ST_Within(B,A)</code>."
msgstr ""
"ST_Contains est le contraire de <xref linkend=\"ST_Within\"/>. Ainsi, "
"<code>ST_Contains(A,B) = ST_Within(B,A)</code>."

#. Tag: para
#: reference_relationship.xml:110
#, no-c-format
msgid ""
"Because the interiors must have a common point, a subtlety of the definition "
"is that polygons and lines do <emphasis>not</emphasis> contain lines and "
"points lying fully in their boundary. For further details see <ulink "
"url=\"http://lin-ear-th-inking.blogspot.com/2007/06/subtleties-of-ogc-covers-"
"spatial.html\">Subtleties of OGC Covers, Contains, Within</ulink>. The <xref "
"linkend=\"ST_Covers\"/> predicate provides a more inclusive relationship."
msgstr ""
"Comme les intérieurs doivent avoir un point commun, une subtilité de la "
"définition est que les polygones et les lignes ne contiennent <emphasis>pas</"
"emphasis> de lignes et de points se trouvant entièrement dans leur limite. "
"Pour plus de détails, voir <ulink url=\"http://lin-ear-th-inking.blogspot."
"com/2007/06/subtleties-of-ogc-covers-spatial.html\">Subtleties of OGC "
"Covers, Contains, Within</ulink>. Le prédicat <xref linkend=\"ST_Covers\"/> "
"fournit une relation plus inclusive."

#. Tag: para
#: reference_relationship.xml:116
#, no-c-format
msgid ""
"&index_aware; To avoid index use, use the function <function>_ST_Contains</"
"function>."
msgstr ""
"&index_aware; Pour éviter l'utilisation d'un index, utilisez la fonction "
"<function>_ST_Contains</function>."

#. Tag: para
#: reference_relationship.xml:119 reference_relationship.xml:394
#: reference_relationship.xml:475 reference_relationship.xml:698
#: reference_relationship.xml:1063 reference_relationship.xml:1268
#: reference_relationship.xml:1353 reference_relationship.xml:1567
#, no-c-format
msgid "Performed by the GEOS module"
msgstr "Effectué par le module GEOS"

#. Tag: para
#: reference_relationship.xml:120 reference_relationship.xml:846
#, no-c-format
msgid ""
"Enhanced: 2.3.0 Enhancement to PIP short-circuit extended to support "
"MultiPoints with few points. Prior versions only supported point in polygon."
msgstr ""
"Amélioré : 2.3.0 Amélioration du court-circuit PIP étendu à la prise en "
"charge des multipoints avec peu de points. Les versions précédentes ne "
"prenaient en charge que les points dans les polygones."

#. Tag: para
#: reference_relationship.xml:123 reference_relationship.xml:314
#: reference_relationship.xml:388 reference_relationship.xml:468
#: reference_relationship.xml:564 reference_relationship.xml:695
#: reference_relationship.xml:761 reference_relationship.xml:1066
#: reference_relationship.xml:1271 reference_relationship.xml:1430
#: reference_relationship.xml:1572
#, no-c-format
msgid ""
"Enhanced: 3.0.0 enabled support for <varname>GEOMETRYCOLLECTION</varname>"
msgstr ""
"Amélioration : 3.0.0 a permis la prise en charge de "
"<varname>GEOMETRYCOLLECTION</varname>"

#. Tag: para
#: reference_relationship.xml:127 reference_relationship.xml:318
#: reference_relationship.xml:392 reference_relationship.xml:472
#: reference_relationship.xml:1576
#, no-c-format
msgid ""
"Do not use this function with invalid geometries. You will get unexpected "
"results."
msgstr ""
"N'utilisez pas cette fonction avec des géométries non valides. Vous "
"obtiendrez des résultats inattendus."

#. Tag: para
#: reference_relationship.xml:130 reference_relationship.xml:397
#: reference_relationship.xml:481 reference_relationship.xml:706
#: reference_relationship.xml:854 reference_relationship.xml:1069
#: reference_relationship.xml:1579
#, no-c-format
msgid ""
"NOTE: this is the \"allowable\" version that returns a boolean, not an "
"integer."
msgstr ""
"NOTE : il s'agit de la version \"autorisée\" qui renvoie un booléen et non "
"un entier."

#. Tag: para
#: reference_relationship.xml:133
#, no-c-format
msgid ""
"&sfs_compliant; s2.1.1.2 // s2.1.13.3 - same as within(geometry B, geometry "
"A)"
msgstr ""
"&sfs_compliant; s2.1.1.2 // s2.1.13.3 - identique à within(geometry B, "
"geometry A)"

#. Tag: para
#: reference_relationship.xml:135
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 5.1.31"
msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.31"

#. Tag: title
#: reference_relationship.xml:140 reference_relationship.xml:324
#: reference_relationship.xml:404 reference_relationship.xml:488
#: reference_relationship.xml:572 reference_relationship.xml:714
#: reference_relationship.xml:770 reference_relationship.xml:933
#: reference_relationship.xml:1019 reference_relationship.xml:1077
#: reference_relationship.xml:1278 reference_relationship.xml:1360
#: reference_relationship.xml:1438 reference_relationship.xml:1589
#: reference_relationship.xml:1655 reference_relationship.xml:1714
#: reference_relationship.xml:1766 reference_relationship.xml:1851
#: reference_relationship.xml:1896
#, no-c-format
msgid "Examples"
msgstr "Exemples"

#. Tag: para
#: reference_relationship.xml:142
#, no-c-format
msgid ""
"<function>ST_Contains</function> returns <varname>TRUE</varname> in the "
"following situations:"
msgstr ""
"<function>ST_Contains</function> renvoie <varname>TRUE</varname> dans les "
"situations suivantes :"

#. Tag: para
#: reference_relationship.xml:154
#, no-c-format
msgid "<varname>LINESTRING</varname> / <varname>MULTIPOINT</varname>"
msgstr "<varname>LINESTRING</varname> / <varname>MULTIPOINT</varname>"

#. Tag: para
#: reference_relationship.xml:164 reference_relationship.xml:1502
#, no-c-format
msgid "<varname>POLYGON</varname> / <varname>POINT</varname>"
msgstr "<varname>POLYGON</varname> / <varname>POINT</varname>"

#. Tag: para
#: reference_relationship.xml:175 reference_relationship.xml:215
#: reference_relationship.xml:246 reference_relationship.xml:1471
#, no-c-format
msgid "<varname>POLYGON</varname> / <varname>LINESTRING</varname>"
msgstr "<varname>POLYGON</varname> / <varname>LINESTRING</varname>"

#. Tag: para
#: reference_relationship.xml:185 reference_relationship.xml:1106
#: reference_relationship.xml:1451 reference_relationship.xml:1461
#, no-c-format
msgid "<varname>POLYGON</varname> / <varname>POLYGON</varname>"
msgstr "<varname>POLYGON</varname> / <varname>POLYGON</varname>"

#. Tag: para
#: reference_relationship.xml:193
#, no-c-format
msgid ""
"<function>ST_Contains</function> returns <varname>FALSE</varname> in the "
"following situations:"
msgstr ""
"La <function>ST_Contains</function> renvoie <varname>FALSE</varname> dans "
"les situations suivantes :"

#. Tag: para
#: reference_relationship.xml:205
#, no-c-format
msgid "<varname>POLYGON</varname> / <varname>MULTIPOINT</varname>"
msgstr "<varname>POLYGON</varname> / <varname>MULTIPOINT</varname>"

#. Tag: para
#: reference_relationship.xml:223
#, no-c-format
msgid ""
"Due to the interior intersection condition <function>ST_Contains</function> "
"returns <varname>FALSE</varname> in the following situations (whereas "
"<function>ST_Covers</function> returns <varname>TRUE</varname>):"
msgstr ""
"En raison de la condition d'intersection intérieure, la "
"<function>ST_Contains</function> renvoie <varname>FALSE</varname> dans les "
"situations suivantes (alors que la <function>ST_Covers</function> renvoie "
"<varname>TRUE</varname>) :"

#. Tag: para
#: reference_relationship.xml:236
#, no-c-format
msgid "<varname>LINESTRING</varname> / <varname>POINT</varname>"
msgstr "<varname>LINESTRING</varname> / <varname>POINT</varname>"

#. Tag: programlisting
#: reference_relationship.xml:254
#, no-c-format
msgid ""
"-- A circle within a circle\n"
"SELECT ST_Contains(smallc, bigc) As smallcontainsbig,\n"
"     ST_Contains(bigc,smallc) As bigcontainssmall,\n"
"     ST_Contains(bigc, ST_Union(smallc, bigc)) as bigcontainsunion,\n"
"     ST_Equals(bigc, ST_Union(smallc, bigc)) as bigisunion,\n"
"     ST_Covers(bigc, ST_ExteriorRing(bigc)) As bigcoversexterior,\n"
"     ST_Contains(bigc, ST_ExteriorRing(bigc)) As bigcontainsexterior\n"
"FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,\n"
"       ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;\n"
"\n"
"-- Result\n"
"  smallcontainsbig | bigcontainssmall | bigcontainsunion | bigisunion | "
"bigcoversexterior | bigcontainsexterior\n"
"------------------+------------------+------------------+------------"
"+-------------------+---------------------\n"
" f                | t                | t                | t          | "
"t        | f\n"
"\n"
"-- Example demonstrating difference between contains and contains properly\n"
"SELECT ST_GeometryType(geomA) As geomtype, ST_Contains(geomA,geomA) AS "
"acontainsa, ST_ContainsProperly(geomA, geomA) AS acontainspropa,\n"
"   ST_Contains(geomA, ST_Boundary(geomA)) As acontainsba, "
"ST_ContainsProperly(geomA, ST_Boundary(geomA)) As acontainspropba\n"
"FROM (VALUES ( ST_Buffer(ST_Point(1,1), 5,1) ),\n"
"       ( ST_MakeLine(ST_Point(1,1), ST_Point(-1,-1) ) ),\n"
"       ( ST_Point(1,1) )\n"
"    ) As foo(geomA);\n"
"\n"
"  geomtype    | acontainsa | acontainspropa | acontainsba | acontainspropba\n"
"--------------+------------+----------------+-------------"
"+-----------------\n"
"ST_Polygon    | t          | f              | f           | f\n"
"ST_LineString | t          | f              | f           | f\n"
"ST_Point      | t          | t              | f           | f"
msgstr ""
"-- Un cercle dans un cercle\n"
"SELECT ST_Contains(smallc, bigc) As smallcontainsbig,\n"
"     ST_Contains(bigc,smallc) As bigcontainssmall,\n"
"     ST_Contains(bigc, ST_Union(smallc, bigc)) as bigcontainsunion,\n"
"     ST_Equals(bigc, ST_Union(smallc, bigc)) as bigisunion,\n"
"     ST_Covers(bigc, ST_ExteriorRing(bigc)) As bigcoversexterior,\n"
"     ST_Contains(bigc, ST_ExteriorRing(bigc)) As bigcontainsexterior\n"
"FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,\n"
"       ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;\n"
"\n"
"-- Résultat\n"
"  smallcontainsbig | bigcontainssmall | bigcontainsunion | bigisunion | "
"bigcoversexterior | bigcontainsexterior\n"
"------------------+------------------+------------------+------------"
"+-------------------+---------------------\n"
" f                | t                | t                | t          | "
"t        | f\n"
"\n"
"-- Exemple démontrant la différence entre \"contains\" et \"contains "
"properly\".\n"
"SELECT ST_GeometryType(geomA) As geomtype, ST_Contains(geomA,geomA) AS "
"acontainsa, ST_ContainsProperly(geomA, geomA) AS acontainspropa,\n"
"   ST_Contains(geomA, ST_Boundary(geomA)) As acontainsba, "
"ST_ContainsProperly(geomA, ST_Boundary(geomA)) As acontainspropba\n"
"FROM (VALUES ( ST_Buffer(ST_Point(1,1), 5,1) ),\n"
"       ( ST_MakeLine(ST_Point(1,1), ST_Point(-1,-1) ) ),\n"
"       ( ST_Point(1,1) )\n"
"    ) As foo(geomA);\n"
"\n"
"  geomtype    | acontainsa | acontainspropa | acontainsba | acontainspropba\n"
"--------------+------------+----------------+-------------"
"+-----------------\n"
"ST_Polygon    | t          | f              | f           | f\n"
"ST_LineString | t          | f              | f           | f\n"
"ST_Point      | t          | t              | f           | f"

#. Tag: para
#: reference_relationship.xml:259
#, no-c-format
msgid ""
", <xref linkend=\"ST_ContainsProperly\"/>, <xref linkend=\"ST_Covers\"/>, "
"<xref linkend=\"ST_CoveredBy\"/>, <xref linkend=\"ST_Equals\"/>, <xref "
"linkend=\"ST_Within\"/>"
msgstr ""
", <xref linkend=\"ST_ContainsProperly\"/>, <xref linkend=\"ST_Covers\"/>, "
"<xref linkend=\"ST_CoveredBy\"/>, <xref linkend=\"ST_Equals\"/>, <xref "
"linkend=\"ST_Within\"/>"

#. Tag: refname
#: reference_relationship.xml:265
#, no-c-format
msgid "ST_ContainsProperly"
msgstr "ST_ContainsProperly"

#. Tag: refpurpose
#: reference_relationship.xml:267
#, no-c-format
msgid "Tests if every point of B lies in the interior of A"
msgstr "Tests si chaque point de B se trouve à l'intérieur de A"

#. Tag: funcprototype
#: reference_relationship.xml:272
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_ContainsProperly</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_ContainsProperly</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef>"

#. Tag: para
#: reference_relationship.xml:287
#, no-c-format
msgid ""
"Returns <varname>true</varname> if every point of B lies in the interior of "
"A (or equivalently, no point of B lies in the the boundary or exterior of A)."
msgstr ""

#. Tag: para
#: reference_relationship.xml:290
#, no-c-format
msgid ""
"In mathematical terms: <emphasis>ST_ContainsProperly(A, B) ⇔ Int(A) ⋂ B = B "
"</emphasis>"
msgstr ""

#. Tag: para
#: reference_relationship.xml:293
#, no-c-format
msgid ""
"A contains B properly if the DE-9IM Intersection Matrix for the two "
"geometries matches [T**FF*FF*]"
msgstr ""

#. Tag: para
#: reference_relationship.xml:296
#, no-c-format
msgid "A does not properly contain itself, but does contain itself."
msgstr "A ne se contient pas proprement, mais se contient."

#. Tag: para
#: reference_relationship.xml:298
#, no-c-format
msgid ""
"A use for this predicate is computing the intersections of a set of "
"geometries with a large polygonal geometry. Since intersection is a fairly "
"slow operation, it can be more efficient to use containsProperly to filter "
"out test geometries which lie fully inside the area. In these cases the "
"intersection is known a priori to be exactly the original test geometry."
msgstr ""
"Ce prédicat peut être utilisé pour calculer les intersections d'un ensemble "
"de géométries avec une grande géométrie polygonale. L'intersection étant une "
"opération assez lente, il peut être plus efficace d'utiliser "
"containsProperly pour filtrer les géométries de test qui se trouvent "
"entièrement à l'intérieur de la zone. Dans ce cas, on sait a priori que "
"l'intersection correspond exactement à la géométrie d'essai originale."

#. Tag: para
#: reference_relationship.xml:303
#, no-c-format
msgid ""
"&index_aware; To avoid index use, use the function "
"<function>_ST_ContainsProperly</function>."
msgstr ""
"&index_aware; Pour éviter l'utilisation d'un index, utilisez la fonction "
"<function>_ST_ContainsProperly</function>."

#. Tag: para
#: reference_relationship.xml:307
#, no-c-format
msgid ""
"The advantage of this predicate over <xref linkend=\"ST_Contains\"/> and "
"<xref linkend=\"ST_Intersects\"/> is that it can be computed more "
"efficiently, with no need to compute topology at individual points."
msgstr ""
"L'avantage de ce prédicat par rapport à <xref linkend=\"ST_Contains\"/> et "
"<xref linkend=\"ST_Intersects\"/> est qu'il peut être calculé plus "
"efficacement, sans qu'il soit nécessaire de calculer la topologie en des "
"points individuels."

#. Tag: para
#: reference_relationship.xml:310
#, no-c-format
msgid "Performed by the GEOS module."
msgstr "Effectué par le module GEOS."

#. Tag: para
#: reference_relationship.xml:311
#, no-c-format
msgid "Availability: 1.4.0"
msgstr "Disponibilité : 1.4.0"

#. Tag: programlisting
#: reference_relationship.xml:325
#, no-c-format
msgid ""
"--a circle within a circle\n"
"  SELECT ST_ContainsProperly(smallc, bigc) As smallcontainspropbig,\n"
"  ST_ContainsProperly(bigc,smallc) As bigcontainspropsmall,\n"
"  ST_ContainsProperly(bigc, ST_Union(smallc, bigc)) as "
"bigcontainspropunion,\n"
"  ST_Equals(bigc, ST_Union(smallc, bigc)) as bigisunion,\n"
"  ST_Covers(bigc, ST_ExteriorRing(bigc)) As bigcoversexterior,\n"
"  ST_ContainsProperly(bigc, ST_ExteriorRing(bigc)) As bigcontainsexterior\n"
"  FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,\n"
"  ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;\n"
"  --Result\n"
"  smallcontainspropbig | bigcontainspropsmall | bigcontainspropunion | "
"bigisunion | bigcoversexterior | bigcontainsexterior\n"
"------------------+------------------+------------------+------------"
"+-------------------+---------------------\n"
" f                     | t                    | f                    | "
"t          | t                 | f\n"
"\n"
" --example demonstrating difference between contains and contains properly\n"
" SELECT ST_GeometryType(geomA) As geomtype, ST_Contains(geomA,geomA) AS "
"acontainsa, ST_ContainsProperly(geomA, geomA) AS acontainspropa,\n"
" ST_Contains(geomA, ST_Boundary(geomA)) As acontainsba, "
"ST_ContainsProperly(geomA, ST_Boundary(geomA)) As acontainspropba\n"
" FROM (VALUES ( ST_Buffer(ST_Point(1,1), 5,1) ),\n"
"      ( ST_MakeLine(ST_Point(1,1), ST_Point(-1,-1) ) ),\n"
"      ( ST_Point(1,1) )\n"
"  ) As foo(geomA);\n"
"\n"
"  geomtype    | acontainsa | acontainspropa | acontainsba | acontainspropba\n"
"--------------+------------+----------------+-------------"
"+-----------------\n"
"ST_Polygon    | t          | f              | f           | f\n"
"ST_LineString | t          | f              | f           | f\n"
"ST_Point      | t          | t              | f           | f"
msgstr ""
"-- un cercle dans un cercle\n"
"  SELECT ST_ContainsProperly(smallc, bigc) As smallcontainspropbig,\n"
"  ST_ContainsProperly(bigc,smallc) As bigcontainspropsmall,\n"
"  ST_ContainsProperly(bigc, ST_Union(smallc, bigc)) as "
"bigcontainspropunion,\n"
"  ST_Equals(bigc, ST_Union(smallc, bigc)) as bigisunion,\n"
"  ST_Covers(bigc, ST_ExteriorRing(bigc)) As bigcoversexterior,\n"
"  ST_ContainsProperly(bigc, ST_ExteriorRing(bigc)) As bigcontainsexterior\n"
"  FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,\n"
"  ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;\n"
"  -- Résultat\n"
"  smallcontainspropbig | bigcontainspropsmall | bigcontainspropunion | "
"bigisunion | bigcoversexterior | bigcontainsexterior\n"
"------------------+------------------+------------------+------------"
"+-------------------+---------------------\n"
" f                     | t                    | f                    | "
"t          | t                 | f\n"
"\n"
" --exemple démontrant la différence entre \"contains\" et \"contains "
"properly\"\n"
" SELECT ST_GeometryType(geomA) As geomtype, ST_Contains(geomA,geomA) AS "
"acontainsa, ST_ContainsProperly(geomA, geomA) AS acontainspropa,\n"
" ST_Contains(geomA, ST_Boundary(geomA)) As acontainsba, "
"ST_ContainsProperly(geomA, ST_Boundary(geomA)) As acontainspropba\n"
" FROM (VALUES ( ST_Buffer(ST_Point(1,1), 5,1) ),\n"
"      ( ST_MakeLine(ST_Point(1,1), ST_Point(-1,-1) ) ),\n"
"      ( ST_Point(1,1) )\n"
"  ) As foo(geomA);\n"
"\n"
"  geomtype    | acontainsa | acontainspropa | acontainsba | acontainspropba\n"
"--------------+------------+----------------+-------------"
"+-----------------\n"
"ST_Polygon    | t          | f              | f           | f\n"
"ST_LineString | t          | f              | f           | f\n"
"ST_Point      | t          | t              | f           | f"

#. Tag: para
#: reference_relationship.xml:330
#, no-c-format
msgid ""
", <xref linkend=\"ST_Boundary\"/>, <xref linkend=\"ST_Contains\"/>, <xref "
"linkend=\"ST_Covers\"/>, <xref linkend=\"ST_CoveredBy\"/>, <xref "
"linkend=\"ST_Equals\"/>, <xref linkend=\"ST_Relate\"/>, <xref "
"linkend=\"ST_Within\"/>"
msgstr ""
", <xref linkend=\"ST_Boundary\"/>, <xref linkend=\"ST_Contains\"/>, <xref "
"linkend=\"ST_Covers\"/>, <xref linkend=\"ST_CoveredBy\"/>, <xref "
"linkend=\"ST_Equals\"/>, <xref linkend=\"ST_Relate\"/>, <xref "
"linkend=\"ST_Within\"/>"

#. Tag: refname
#: reference_relationship.xml:336
#, no-c-format
msgid "ST_CoveredBy"
msgstr "ST_CoveredBy"

#. Tag: refpurpose
#: reference_relationship.xml:338
#, no-c-format
msgid "Tests if every point of A lies in B"
msgstr "Tests si chaque point de A se trouve dans B"

#. Tag: funcsynopsis
#: reference_relationship.xml:342
#, no-c-format
msgid ""
"<funcprototype> <funcdef>boolean <function>ST_CoveredBy</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef> </"
"funcprototype> <funcprototype> <funcdef>boolean <function>ST_CoveredBy</"
"function></funcdef> <paramdef><type>geography </type> <parameter>geogA</"
"parameter></paramdef> <paramdef><type>geography </type> <parameter>geogB</"
"parameter></paramdef> </funcprototype>"
msgstr ""
"<funcprototype> <funcdef>boolean <function>ST_CoveredBy</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef> </"
"funcprototype> <funcprototype> <funcdef>boolean <function>ST_CoveredBy</"
"function></funcdef> <paramdef><type>geography </type> <parameter>geogA</"
"parameter></paramdef> <paramdef><type>geography </type> <parameter>geogB</"
"parameter></paramdef> </funcprototype>"

#. Tag: para
#: reference_relationship.xml:368
#, no-c-format
msgid ""
"Returns <varname>true</varname> if every point in Geometry/Geography A lies "
"inside (i.e. intersects the interior or boundary of) Geometry/Geography B. "
"Equivalently, tests that no point of A lies outside (in the exterior of) B."
msgstr ""
"Renvoie <varname>true</varname> si chaque point de la geometry/geography A "
"se trouve à l'intérieur (c'est-à-dire coupe l'intérieur ou la limite) de la "
"geometry/geography B. De manière équivalente, teste qu'aucun point de A ne "
"se trouve à l'extérieur (dans l'extérieur) de B."

#. Tag: para
#: reference_relationship.xml:374
#, no-c-format
msgid ""
"In mathematical terms: <emphasis>ST_CoveredBy(A, B) ⇔ A ⋂ B = A </emphasis>"
msgstr ""

#. Tag: para
#: reference_relationship.xml:377
#, no-c-format
msgid ""
"ST_CoveredBy is the converse of <xref linkend=\"ST_Covers\"/>. So, "
"<code>ST_CoveredBy(A,B) = ST_Covers(B,A)</code>."
msgstr ""
"ST_CoveredBy est le contraire de <xref linkend=\"ST_Covers\"/>. Ainsi, "
"<code>ST_CoveredBy(A,B) = ST_Covers(B,A)</code>."

#. Tag: para
#: reference_relationship.xml:380
#, no-c-format
msgid ""
"Generally this function should be used instead of <xref "
"linkend=\"ST_Within\"/>, since it has a simpler definition which does not "
"have the quirk that \"boundaries are not within their geometry\"."
msgstr ""
"En général, cette fonction devrait être utilisée à la place de <xref "
"linkend=\"ST_Within\"/>, car elle a une définition plus simple qui n'a pas "
"la particularité que \"les limites ne sont pas à l'intérieur de leur "
"géométrie\"."

#. Tag: para
#: reference_relationship.xml:384
#, no-c-format
msgid ""
"&index_aware; To avoid index use, use the function <function>_ST_CoveredBy</"
"function>."
msgstr ""
"&index_aware; Pour éviter l'utilisation d'un index, utilisez la fonction "
"<function>_ST_CoveredBy</function>."

#. Tag: para
#: reference_relationship.xml:395 reference_relationship.xml:479
#, no-c-format
msgid "Availability: 1.2.2"
msgstr "Disponibilité : 1.2.2"

#. Tag: para
#: reference_relationship.xml:400 reference_relationship.xml:484
#, no-c-format
msgid "Not an OGC standard, but Oracle has it too."
msgstr "Il ne s'agit pas d'une norme de l'OGC, mais Oracle l'a également."

#. Tag: programlisting
#: reference_relationship.xml:405
#, no-c-format
msgid ""
"--a circle coveredby a circle\n"
"SELECT ST_CoveredBy(smallc,smallc) As smallinsmall,\n"
"  ST_CoveredBy(smallc, bigc) As smallcoveredbybig,\n"
"  ST_CoveredBy(ST_ExteriorRing(bigc), bigc) As exteriorcoveredbybig,\n"
"  ST_Within(ST_ExteriorRing(bigc),bigc) As exeriorwithinbig\n"
"FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,\n"
"  ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;\n"
"  --Result\n"
" smallinsmall | smallcoveredbybig | exteriorcoveredbybig | exeriorwithinbig\n"
"--------------+-------------------+----------------------"
"+------------------\n"
" t            | t                 | t                    | f\n"
"(1 row)"
msgstr ""
"-- un cercle couvert par un cercle\n"
"SELECT ST_CoveredBy(smallc,smallc) As smallinsmall,\n"
"  ST_CoveredBy(smallc, bigc) As smallcoveredbybig,\n"
"  ST_CoveredBy(ST_ExteriorRing(bigc), bigc) As exteriorcoveredbybig,\n"
"  ST_Within(ST_ExteriorRing(bigc),bigc) As exeriorwithinbig\n"
"FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,\n"
"  ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;\n"
"  -- Résultat\n"
" smallinsmall | smallcoveredbybig | exteriorcoveredbybig | exeriorwithinbig\n"
"--------------+-------------------+----------------------"
"+------------------\n"
" t            | t                 | t                    | f\n"
"(1 row)"

#. Tag: para
#: reference_relationship.xml:410
#, no-c-format
msgid ""
", <xref linkend=\"ST_Covers\"/>, <xref linkend=\"ST_ExteriorRing\"/>, <xref "
"linkend=\"ST_Within\"/>"
msgstr ""
", <xref linkend=\"ST_Covers\"/>, <xref linkend=\"ST_ExteriorRing\"/>, <xref "
"linkend=\"ST_Within\"/>"

#. Tag: refname
#: reference_relationship.xml:416
#, no-c-format
msgid "ST_Covers"
msgstr "ST_Covers"

#. Tag: refpurpose
#: reference_relationship.xml:418
#, no-c-format
msgid "Tests if every point of B lies in A"
msgstr "Tests si chaque point de B est situé dans A"

#. Tag: funcsynopsis
#: reference_relationship.xml:422
#, no-c-format
msgid ""
"<funcprototype> <funcdef>boolean <function>ST_Covers</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef> </"
"funcprototype> <funcprototype> <funcdef>boolean <function>ST_Covers</"
"function></funcdef> <paramdef><type>geography </type> <parameter>geogpolyA</"
"parameter></paramdef> <paramdef><type>geography </type> "
"<parameter>geogpointB</parameter></paramdef> </funcprototype>"
msgstr ""
"<funcprototype> <funcdef>boolean <function>ST_Covers</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef> </"
"funcprototype> <funcprototype> <funcdef>boolean <function>ST_Covers</"
"function></funcdef> <paramdef><type>geography </type> <parameter>geogpolyA</"
"parameter></paramdef> <paramdef><type>geography </type> "
"<parameter>geogpointB</parameter></paramdef> </funcprototype>"

#. Tag: para
#: reference_relationship.xml:447
#, no-c-format
msgid ""
"Returns <varname>true</varname> if every point in Geometry/Geography B lies "
"inside (i.e. intersects the interior or boundary of) Geometry/Geography A. "
"Equivalently, tests that no point of B lies outside (in the exterior of) A."
msgstr ""
"Renvoie <varname>true</varname> si chaque point de la geometry/geography B "
"se trouve à l'intérieur (c'est-à-dire qu'il coupe l'intérieur ou la limite) "
"de la geometry/geography A. De façon équivalente, teste qu'aucun point de B "
"ne se trouve à l'extérieur (dans l'extérieur) de A."

#. Tag: para
#: reference_relationship.xml:453
#, no-c-format
msgid ""
"In mathematical terms: <emphasis>ST_Covers(A, B) ⇔ A ⋂ B = B </emphasis>"
msgstr ""

#. Tag: para
#: reference_relationship.xml:456
#, no-c-format
msgid ""
"ST_Covers is the converse of <xref linkend=\"ST_CoveredBy\"/>. So, "
"<code>ST_Covers(A,B) = ST_CoveredBy(B,A)</code>."
msgstr ""
"ST_Covers est le contraire de <xref linkend=\"ST_CoveredBy\"/>. Ainsi, "
"<code>ST_Covers(A,B) = ST_CoveredBy(B,A)</code>."

#. Tag: para
#: reference_relationship.xml:459
#, no-c-format
msgid ""
"Generally this function should be used instead of <xref "
"linkend=\"ST_Contains\"/>, since it has a simpler definition which does not "
"have the quirk that \"geometries do not contain their boundary\"."
msgstr ""
"En général, cette fonction devrait être utilisée à la place de <xref "
"linkend=\"ST_Contains\"/>, car elle a une définition plus simple qui n'a pas "
"la particularité que \"les géométries ne contiennent pas leur frontière\"."

#. Tag: para
#: reference_relationship.xml:464
#, no-c-format
msgid ""
"&index_aware; To avoid index use, use the function <function>_ST_Covers</"
"function>."
msgstr ""
"&index_aware; Pour éviter l'utilisation d'un index, utilisez la fonction "
"<function>_ST_Covers</function>."

#. Tag: para
#: reference_relationship.xml:476
#, no-c-format
msgid ""
"Enhanced: 2.4.0 Support for polygon in polygon and line in polygon added for "
"geography type"
msgstr ""
"Amélioration : 2.4.0 Ajout de la prise en charge des polygones dans les "
"polygones et des lignes dans les polygones pour le type geography"

#. Tag: para
#: reference_relationship.xml:477 reference_relationship.xml:1569
#, no-c-format
msgid ""
"Enhanced: 2.3.0 Enhancement to PIP short-circuit for geometry extended to "
"support MultiPoints with few points. Prior versions only supported point in "
"polygon."
msgstr ""
"Amélioration : 2.3.0 Amélioration du court-circuit PIP pour la géométrie "
"étendue à la prise en charge des multipoints avec peu de points. Les "
"versions précédentes ne prenaient en charge que les points dans les "
"polygones."

#. Tag: para
#: reference_relationship.xml:478
#, no-c-format
msgid "Availability: 1.5 - support for geography was introduced."
msgstr "Disponibilité : 1.5 - le support de la geography a été introduit."

#. Tag: para
#: reference_relationship.xml:489
#, no-c-format
msgid "Geometry example"
msgstr "Exemple géométrique"

#. Tag: programlisting
#: reference_relationship.xml:490
#, no-c-format
msgid ""
"--a circle covering a circle\n"
"SELECT ST_Covers(smallc,smallc) As smallinsmall,\n"
"  ST_Covers(smallc, bigc) As smallcoversbig,\n"
"  ST_Covers(bigc, ST_ExteriorRing(bigc)) As bigcoversexterior,\n"
"  ST_Contains(bigc, ST_ExteriorRing(bigc)) As bigcontainsexterior\n"
"FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,\n"
"  ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;\n"
"  --Result\n"
" smallinsmall | smallcoversbig | bigcoversexterior | bigcontainsexterior\n"
"--------------+----------------+-------------------+---------------------\n"
" t            | f              | t                 | f\n"
"(1 row)"
msgstr ""
"-- un cercle recouvrant un cercle\n"
"SELECT ST_Covers(smallc,smallc) As smallinsmall,\n"
"  ST_Covers(smallc, bigc) As smallcoversbig,\n"
"  ST_Covers(bigc, ST_ExteriorRing(bigc)) As bigcoversexterior,\n"
"  ST_Contains(bigc, ST_ExteriorRing(bigc)) As bigcontainsexterior\n"
"FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,\n"
"  ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;\n"
"  -- Résultat\n"
" smallinsmall | smallcoversbig | bigcoversexterior | bigcontainsexterior\n"
"--------------+----------------+-------------------+---------------------\n"
" t            | f              | t                 | f\n"
"(1 row)"

#. Tag: para
#: reference_relationship.xml:491
#, no-c-format
msgid "Geeography Example"
msgstr "Exemple géographique"

#. Tag: programlisting
#: reference_relationship.xml:492
#, no-c-format
msgid ""
"-- a point with a 300 meter buffer compared to a point, a point and its 10 "
"meter buffer\n"
"SELECT ST_Covers(geog_poly, geog_pt) As poly_covers_pt,\n"
"  ST_Covers(ST_Buffer(geog_pt,10), geog_pt) As buff_10m_covers_cent\n"
"  FROM (SELECT ST_Buffer(ST_GeogFromText('SRID=4326;POINT(-99.327 "
"31.4821)'), 300) As geog_poly,\n"
"        ST_GeogFromText('SRID=4326;POINT(-99.33 31.483)') As geog_pt ) As "
"foo;\n"
"\n"
" poly_covers_pt | buff_10m_covers_cent\n"
"----------------+------------------\n"
" f              | t"
msgstr ""
"-- un point avec une zone tampon de 300 mètres comparé à un point, un point "
"et sa zone tampon de 10 mètres\n"
"SELECT ST_Covers(geog_poly, geog_pt) As poly_covers_pt,\n"
"  ST_Covers(ST_Buffer(geog_pt,10), geog_pt) As buff_10m_covers_cent\n"
"  FROM (SELECT ST_Buffer(ST_GeogFromText('SRID=4326;POINT(-99.327 "
"31.4821)'), 300) As geog_poly,\n"
"        ST_GeogFromText('SRID=4326;POINT(-99.33 31.483)') As geog_pt ) As "
"foo;\n"
"\n"
" poly_covers_pt | buff_10m_covers_cent\n"
"----------------+------------------\n"
" f              | t"

#. Tag: para
#: reference_relationship.xml:497
#, no-c-format
msgid ", <xref linkend=\"ST_CoveredBy\"/>, <xref linkend=\"ST_Within\"/>"
msgstr ", <xref linkend=\"ST_CoveredBy\"/>, <xref linkend=\"ST_Within\"/>"

#. Tag: refname
#: reference_relationship.xml:503
#, no-c-format
msgid "ST_Crosses"
msgstr "ST_Crosses"

#. Tag: refpurpose
#: reference_relationship.xml:505
#, no-c-format
msgid ""
"Tests if two geometries have some, but not all, interior points in common"
msgstr ""
"Teste si deux géométries ont en commun certains points intérieurs, mais pas "
"tous"

#. Tag: funcprototype
#: reference_relationship.xml:510
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_Crosses</function></funcdef> "
"<paramdef><type>geometry </type><parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type><parameter>g2</parameter></paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_Crosses</function></funcdef> "
"<paramdef><type>geometry </type><parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type><parameter>g2</parameter></paramdef>"

#. Tag: para
#: reference_relationship.xml:523
#, no-c-format
msgid ""
"Compares two geometry objects and returns <varname>true</varname> if their "
"intersection \"spatially crosses\"; that is, the geometries have some, but "
"not all interior points in common. The intersection of the interiors of the "
"geometries must be non-empty and must have dimension less than the maximum "
"dimension of the two input geometries, and the intersection of the two "
"geometries must not equal either geometry. Otherwise, it returns "
"<varname>false</varname>. The crosses relation is symmetric and irreflexive."
msgstr ""

#. Tag: para
#: reference_relationship.xml:533
#, no-c-format
msgid ""
"In mathematical terms: <emphasis>ST_Crosses(A, B) ⇔ (dim( Int(A) ⋂ Int(B) ) "
"&lt; max( dim( Int(A) ), dim( Int(B) ) )) ∧ (A ⋂ B ≠ A) ∧ (A ⋂ B ≠ B) </"
"emphasis>"
msgstr ""

#. Tag: para
#: reference_relationship.xml:536
#, no-c-format
msgid "Geometries cross if their DE-9IM Intersection Matrix matches:"
msgstr ""
"Les géométries se croisent si leur matrice d'intersection DE-9IM correspond :"

#. Tag: para
#: reference_relationship.xml:540
#, no-c-format
msgid ""
"<code>T*T******</code> for Point/Line, Point/Area, and Line/Area situations"
msgstr ""
"<code>T*T******</code> pour les situations point/ligne, point/zone et ligne/"
"zone"

#. Tag: para
#: reference_relationship.xml:544
#, no-c-format
msgid ""
"<code>T*****T**</code> for Line/Point, Area/Point, and Area/Line situations"
msgstr ""
"<code>T*****T**</code> pour les situations Ligne/Point, Zone/Point et Zone/"
"Ligne"

#. Tag: para
#: reference_relationship.xml:548
#, no-c-format
msgid "<code>0********</code> for Line/Line situations"
msgstr "<code>0********</code> pour les situations ligne/ligne"

#. Tag: para
#: reference_relationship.xml:552
#, no-c-format
msgid ""
"the result is <varname>false</varname> for Point/Point and Area/Area "
"situations"
msgstr ""

#. Tag: para
#: reference_relationship.xml:556
#, no-c-format
msgid ""
"The OpenGIS Simple Features Specification defines this predicate only for "
"Point/Line, Point/Area, Line/Line, and Line/Area situations. JTS / GEOS "
"extends the definition to apply to Line/Point, Area/Point and Area/Line "
"situations as well. This makes the relation symmetric."
msgstr ""
"La spécification OpenGIS Simple Features définit ce prédicat uniquement pour "
"les situations Point/Ligne, Point/Zone, Ligne/Ligne et Ligne/Zone. Le STC / "
"GEOS étend la définition pour qu'elle s'applique également aux situations "
"Ligne/Point, Zone/Point et Zone/Ligne. Cela rend la relation symétrique."

#. Tag: para
#: reference_relationship.xml:567
#, no-c-format
msgid "&sfs_compliant; s2.1.13.3"
msgstr "&sfs_compliant; s2.1.13.3"

#. Tag: para
#: reference_relationship.xml:568
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 5.1.29"
msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.29"

#. Tag: para
#: reference_relationship.xml:574
#, no-c-format
msgid "The following situations all return <varname>true</varname>."
msgstr "Les situations suivantes renvoient toutes <varname>true</varname>."

#. Tag: para
#: reference_relationship.xml:586
#, no-c-format
msgid "<varname>MULTIPOINT</varname> / <varname>LINESTRING</varname>"
msgstr "<varname>MULTIPOINT</varname> / <varname>LINESTRING</varname>"

#. Tag: para
#: reference_relationship.xml:596
#, no-c-format
msgid "<varname>MULTIPOINT</varname> / <varname>POLYGON</varname>"
msgstr "<varname>MULTIPOINT</varname> / <varname>POLYGON</varname>"

#. Tag: para
#: reference_relationship.xml:608
#, no-c-format
msgid "<varname>LINESTRING</varname> / <varname>POLYGON</varname>"
msgstr "<varname>LINESTRING</varname> / <varname>POLYGON</varname>"

#. Tag: para
#: reference_relationship.xml:618 reference_relationship.xml:1098
#: reference_relationship.xml:1482 reference_relationship.xml:1492
#, no-c-format
msgid "<varname>LINESTRING</varname> / <varname>LINESTRING</varname>"
msgstr "<varname>LINESTRING</varname> / <varname>LINESTRING</varname>"

#. Tag: para
#: reference_relationship.xml:626
#, no-c-format
msgid ""
"Consider a situation where a user has two tables: a table of roads and a "
"table of highways."
msgstr ""
"Prenons le cas d'un utilisateur qui dispose de deux tables : une table de "
"routes et une table d'autoroutes."

#. Tag: programlisting
#: reference_relationship.xml:634
#, no-c-format
msgid ""
"CREATE TABLE roads (\n"
"  id serial NOT NULL,\n"
"  geom geometry,\n"
"  CONSTRAINT roads_pkey PRIMARY KEY (road_id)\n"
");"
msgstr ""
"CREATE TABLE roads (\n"
"  id serial NOT NULL,\n"
"  geom geometry,\n"
"  CONSTRAINT roads_pkey PRIMARY KEY (road_id)\n"
");"

#. Tag: programlisting
#: reference_relationship.xml:638
#, no-c-format
msgid ""
"CREATE TABLE highways (\n"
"  id serial NOT NULL,\n"
"  the_gem geometry,\n"
"  CONSTRAINT roads_pkey PRIMARY KEY (road_id)\n"
");"
msgstr ""
"CREATE TABLE highways (\n"
"  id serial NOT NULL,\n"
"  the_gem geometry,\n"
"  CONSTRAINT roads_pkey PRIMARY KEY (road_id)\n"
");"

#. Tag: para
#: reference_relationship.xml:645
#, no-c-format
msgid ""
"To determine a list of roads that cross a highway, use a query similiar to:"
msgstr ""
"Pour obtenir une liste des routes qui traversent une autoroute, utilisez une "
"requête similaire à :"

#. Tag: programlisting
#: reference_relationship.xml:649
#, no-c-format
msgid ""
"SELECT roads.id\n"
"FROM roads, highways\n"
"WHERE ST_Crosses(roads.geom, highways.geom);"
msgstr ""
"SELECT roads.id\n"
"FROM roads, highways\n"
"WHERE ST_Crosses(roads.geom, highways.geom);"

#. Tag: para
#: reference_relationship.xml:655
#, no-c-format
msgid ", <xref linkend=\"ST_Overlaps\"/>"
msgstr ", <xref linkend=\"ST_Overlaps\"/>"

#. Tag: refname
#: reference_relationship.xml:661
#, no-c-format
msgid "ST_Disjoint"
msgstr "ST_Disjoint"

#. Tag: refpurpose
#: reference_relationship.xml:663
#, no-c-format
msgid "Tests if two geometries have no points in common"
msgstr "Teste si deux géométries n'ont pas de points communs"

#. Tag: funcprototype
#: reference_relationship.xml:667
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_Disjoint</function></funcdef> <paramdef> "
"<type>geometry</type> <parameter>A</parameter> </paramdef> <paramdef> "
"<type>geometry</type> <parameter>B</parameter> </paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_Disjoint</function></funcdef> <paramdef> "
"<type>geometry</type> <parameter>A</parameter> </paramdef> <paramdef> "
"<type>geometry</type> <parameter>B</parameter> </paramdef>"

#. Tag: para
#: reference_relationship.xml:683
#, no-c-format
msgid ""
"Returns <varname>true</varname> if two geometries are disjoint. Geometries "
"are disjoint if they have no point in common."
msgstr ""

#. Tag: para
#: reference_relationship.xml:687
#, no-c-format
msgid ""
"If any other spatial relationship is true for a pair of geometries, they are "
"not disjoint. Disjoint implies that <xref linkend=\"ST_Intersects\"/> is "
"false."
msgstr ""

#. Tag: para
#: reference_relationship.xml:691
#, no-c-format
msgid ""
"In mathematical terms: <emphasis>ST_Disjoint(A, B) ⇔ A ⋂ B = ∅ </emphasis>"
msgstr ""

#. Tag: para
#: reference_relationship.xml:700
#, no-c-format
msgid ""
"This function call does not use indexes. A negated <xref "
"linkend=\"ST_Intersects\"/> predicate can be used as a more performant "
"alternative that uses indexes: <code>ST_Disjoint(A,B) = NOT ST_Intersects(A,"
"B)</code>"
msgstr ""
"Cet appel de fonction n'utilise pas d'index. Un prédicat négatif <xref "
"linkend=\"ST_Intersects\"/> peut être utilisé comme une alternative plus "
"performante qui utilise des index : <code>ST_Disjoint(A,B) = NOT "
"ST_Intersects(A,B)</code>"

#. Tag: para
#: reference_relationship.xml:709
#, no-c-format
msgid "&sfs_compliant; s2.1.1.2 //s2.1.13.3 - a.Relate(b, 'FF*FF****')"
msgstr "&sfs_compliant; s2.1.1.2 //s2.1.13.3 - a.Relate(b, 'FF*FF****')"

#. Tag: para
#: reference_relationship.xml:711
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 5.1.26"
msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.26"

#. Tag: programlisting
#: reference_relationship.xml:716
#, no-c-format
msgid ""
"SELECT ST_Disjoint('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 2 )'::"
"geometry);\n"
" st_disjoint\n"
"---------------\n"
" t\n"
"(1 row)\n"
"SELECT ST_Disjoint('POINT(0 0)'::geometry, 'LINESTRING ( 0 0, 0 2 )'::"
"geometry);\n"
" st_disjoint\n"
"---------------\n"
" f\n"
"(1 row)"
msgstr ""
"SELECT ST_Disjoint('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 2 )'::"
"geometry);\n"
" st_disjoint\n"
"---------------\n"
" t\n"
"(1 row)\n"
"SELECT ST_Disjoint('POINT(0 0)'::geometry, 'LINESTRING ( 0 0, 0 2 )'::"
"geometry);\n"
" st_disjoint\n"
"---------------\n"
" f\n"
"(1 row)"

#. Tag: refname
#: reference_relationship.xml:727
#, no-c-format
msgid "ST_Equals"
msgstr "ST_Equals"

#. Tag: refpurpose
#: reference_relationship.xml:729
#, no-c-format
msgid "Tests if two geometries include the same set of points"
msgstr "Teste si deux géométries comprennent le même ensemble de points"

#. Tag: funcprototype
#: reference_relationship.xml:734
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_Equals</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_Equals</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"

#. Tag: para
#: reference_relationship.xml:745
#, no-c-format
msgid ""
"Returns <varname>true</varname> if the given geometries are \"topologically "
"equal\". Use this for a 'better' answer than '='. Topological equality means "
"that the geometries have the same dimension, and their point-sets occupy the "
"same space. This means that the order of vertices may be different in "
"topologically equal geometries. To verify the order of points is consistent "
"use <xref linkend=\"ST_OrderingEquals\"/> (it must be noted "
"ST_OrderingEquals is a little more stringent than simply verifying order of "
"points are the same)."
msgstr ""

#. Tag: para
#: reference_relationship.xml:754
#, no-c-format
msgid "In mathematical terms: <emphasis>ST_Equals(A, B) ⇔ A = B </emphasis>"
msgstr ""

#. Tag: para
#: reference_relationship.xml:757
#, no-c-format
msgid ""
"The following relation holds: <emphasis>ST_Equals(A, B) ⇔ ST_Within(A,B) ∧ "
"ST_Within(B,A) </emphasis>"
msgstr ""

#. Tag: para
#: reference_relationship.xml:764
#, no-c-format
msgid "&sfs_compliant; s2.1.1.2"
msgstr "&sfs_compliant; s2.1.1.2"

#. Tag: para
#: reference_relationship.xml:765
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 5.1.24"
msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.24"

#. Tag: para
#: reference_relationship.xml:766
#, no-c-format
msgid ""
"Changed: 2.2.0 Returns true even for invalid geometries if they are binary "
"equal"
msgstr ""
"Modifié : 2.2.0 Retourne vrai même pour les géométries invalides si elles "
"sont binairement égales"

#. Tag: programlisting
#: reference_relationship.xml:772
#, no-c-format
msgid ""
"SELECT ST_Equals(ST_GeomFromText('LINESTRING(0 0, 10 10)'),\n"
"    ST_GeomFromText('LINESTRING(0 0, 5 5, 10 10)'));\n"
" st_equals\n"
"-----------\n"
" t\n"
"(1 row)\n"
"\n"
"SELECT ST_Equals(ST_Reverse(ST_GeomFromText('LINESTRING(0 0, 10 10)')),\n"
"    ST_GeomFromText('LINESTRING(0 0, 5 5, 10 10)'));\n"
" st_equals\n"
"-----------\n"
" t\n"
"(1 row)"
msgstr ""
"SELECT ST_Equals(ST_GeomFromText('LINESTRING(0 0, 10 10)'),\n"
"    ST_GeomFromText('LINESTRING(0 0, 5 5, 10 10)'));\n"
" st_equals\n"
"-----------\n"
" t\n"
"(1 row)\n"
"\n"
"SELECT ST_Equals(ST_Reverse(ST_GeomFromText('LINESTRING(0 0, 10 10)')),\n"
"    ST_GeomFromText('LINESTRING(0 0, 5 5, 10 10)'));\n"
" st_equals\n"
"-----------\n"
" t\n"
"(1 row)"

#. Tag: para
#: reference_relationship.xml:778
#, no-c-format
msgid ""
", <xref linkend=\"ST_OrderingEquals\"/>, <xref linkend=\"ST_Reverse\"/>, "
"<xref linkend=\"ST_Within\"/>"
msgstr ""
", <xref linkend=\"ST_OrderingEquals\"/>, <xref linkend=\"ST_Reverse\"/>, "
"<xref linkend=\"ST_Within\"/>"

#. Tag: refname
#: reference_relationship.xml:786
#, no-c-format
msgid "ST_Intersects"
msgstr "ST_Intersects"

#. Tag: refpurpose
#: reference_relationship.xml:788
#, no-c-format
msgid ""
"Tests if two geometries intersect (they have at least one point in common)"
msgstr ""
"Teste si deux géométries se croisent (elles ont au moins un point en commun)"

#. Tag: funcsynopsis
#: reference_relationship.xml:791
#, no-c-format
msgid ""
"<funcprototype> <funcdef>boolean <function>ST_Intersects</function></"
"funcdef> <paramdef> <type>geometry</type> <parameter>geomA</parameter> </"
"paramdef> <paramdef> <type>geometry</type> <parameter>geomB</parameter> </"
"paramdef> </funcprototype> <funcprototype> <funcdef>boolean "
"<function>ST_Intersects</function></funcdef> <paramdef> <type>geography</"
"type> <parameter>geogA</parameter> </paramdef> <paramdef> <type>geography</"
"type> <parameter>geogB</parameter> </paramdef> </funcprototype>"
msgstr ""
"<funcprototype> <funcdef>boolean <function>ST_Intersects</function></"
"funcdef> <paramdef> <type>geometry</type> <parameter>geomA</parameter> </"
"paramdef> <paramdef> <type>geometry</type> <parameter>geomB</parameter> </"
"paramdef> </funcprototype> <funcprototype> <funcdef>boolean "
"<function>ST_Intersects</function></funcdef> <paramdef> <type>geography</"
"type> <parameter>geogA</parameter> </paramdef> <paramdef> <type>geography</"
"type> <parameter>geogB</parameter> </paramdef> </funcprototype>"

#. Tag: para
#: reference_relationship.xml:818
#, no-c-format
msgid ""
"Returns <varname>true</varname> if two geometries intersect. Geometries "
"intersect if they have any point in common."
msgstr ""

#. Tag: para
#: reference_relationship.xml:822
#, no-c-format
msgid ""
"For geography, a distance tolerance of 0.00001 meters is used (so points "
"that are very close are considered to intersect)."
msgstr ""
"Pour les objets de type geography, une tolérance de distance de 0,00001 "
"mètre est utilisée (les points très proches sont donc considérés comme se "
"croisant)."

#. Tag: para
#: reference_relationship.xml:826
#, no-c-format
msgid ""
"In mathematical terms: <emphasis>ST_Intersects(A, B) ⇔ A ⋂ B ≠ ∅ </emphasis>"
msgstr ""

#. Tag: para
#: reference_relationship.xml:829
#, no-c-format
msgid ""
"Geometries intersect if their DE-9IM Intersection Matrix matches one of:"
msgstr ""
"Les géométries se croisent si leur matrice d'intersection DE-9IM correspond "
"à l'un des éléments suivants :"

#. Tag: code
#: reference_relationship.xml:833
#, no-c-format
msgid "T********"
msgstr "T********"

#. Tag: code
#: reference_relationship.xml:834
#, no-c-format
msgid "*T*******"
msgstr "*T*******"

#. Tag: code
#: reference_relationship.xml:835
#, no-c-format
msgid "***T*****"
msgstr "***T*****"

#. Tag: code
#: reference_relationship.xml:836
#, no-c-format
msgid "****T****"
msgstr "****T****"

#. Tag: para
#: reference_relationship.xml:839
#, no-c-format
msgid ""
"Spatial intersection is implied by all the other spatial relationship tests, "
"except <xref linkend=\"ST_Disjoint\"/>, which tests that geometries do NOT "
"intersect."
msgstr ""
"L'intersection spatiale est impliquée par tous les autres tests de relations "
"spatiales, à l'exception de <xref linkend=\"ST_Disjoint\"/>, qui teste que "
"les géométries ne se croisent PAS."

#. Tag: para
#: reference_relationship.xml:844
#, no-c-format
msgid ""
"Changed: 3.0.0 SFCGAL version removed and native support for 2D TINS added."
msgstr ""
"Modifié : 3.0.0 La version SFCGAL a été supprimée et la prise en charge "
"native des TINS 2D a été ajoutée."

#. Tag: para
#: reference_relationship.xml:845
#, no-c-format
msgid "Enhanced: 2.5.0 Supports GEOMETRYCOLLECTION."
msgstr "Amélioré : 2.5.0 Supporte GEOMETRYCOLLECTION."

#. Tag: para
#: reference_relationship.xml:847
#, no-c-format
msgid "Performed by the GEOS module (for geometry), geography is native"
msgstr "Effectuée par le module GEOS (pour geometry), la geography est native"

#. Tag: para
#: reference_relationship.xml:848
#, no-c-format
msgid "Availability: 1.5 support for geography was introduced."
msgstr ""
"Disponibilité : la version 1.5 a introduit la prise en charge du type "
"geography."

#. Tag: para
#: reference_relationship.xml:850
#, no-c-format
msgid ""
"For geography, this function has a distance tolerance of about 0.00001 "
"meters and uses the sphere rather than spheroid calculation."
msgstr ""
"Pour geography, cette fonction a une tolérance de distance d'environ 0,00001 "
"mètre et utilise la sphère plutôt que le calcul du sphéroïde."

#. Tag: para
#: reference_relationship.xml:857
#, no-c-format
msgid ""
"&sfs_compliant; s2.1.1.2 //s2.1.13.3 - ST_Intersects(g1, g2 ) --&gt; Not "
"(ST_Disjoint(g1, g2 ))"
msgstr ""
"&sfs_compliant; s2.1.1.2 //s2.1.13.3 - ST_Intersects(g1, g2 ) --&gt; Not "
"(ST_Disjoint(g1, g2 ))"

#. Tag: para
#: reference_relationship.xml:860
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 5.1.27"
msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.27"

#. Tag: para
#: reference_relationship.xml:861
#, no-c-format
msgid "&curve_support;"
msgstr "&curve_support;"

#. Tag: programlisting
#: reference_relationship.xml:867
#, no-c-format
msgid ""
"SELECT ST_Intersects('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 2 )'::"
"geometry);\n"
" st_intersects\n"
"---------------\n"
" f\n"
"(1 row)\n"
"SELECT ST_Intersects('POINT(0 0)'::geometry, 'LINESTRING ( 0 0, 0 2 )'::"
"geometry);\n"
" st_intersects\n"
"---------------\n"
" t\n"
"(1 row)\n"
"\n"
"-- Look up in table. Make sure table has a GiST index on geometry column for "
"faster lookup.\n"
"SELECT id, name FROM cities WHERE ST_Intersects(geom, 'SRID=4326;POLYGON((28 "
"53,27.707 52.293,27 52,26.293 52.293,26 53,26.293 53.707,27 54,27.707 "
"53.707,28 53))');\n"
" id | name\n"
"----+-------\n"
"  2 | Minsk\n"
"(1 row)"
msgstr ""
"SELECT ST_Intersects('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 2 )'::"
"geometry);\n"
" st_intersects\n"
"---------------\n"
" f\n"
"(1 row)\n"
"SELECT ST_Intersects('POINT(0 0)'::geometry, 'LINESTRING ( 0 0, 0 2 )'::"
"geometry);\n"
" st_intersects\n"
"---------------\n"
" t\n"
"(1 row)\n"
"\n"
"-- Recherche dans la table. Assurez-vous que la table possède un index GiST "
"sur la colonne géométrie pour une recherche plus rapide.\n"
"SELECT id, name FROM cities WHERE ST_Intersects(geom, 'SRID=4326;POLYGON((28 "
"53,27.707 52.293,27 52,26.293 52.293,26 53,26.293 53.707,27 54,27.707 "
"53.707,28 53))');\n"
" id | name\n"
"----+-------\n"
"  2 | Minsk\n"
"(1 row)"

#. Tag: title
#: reference_relationship.xml:870
#, no-c-format
msgid "Geography Examples"
msgstr "Exemples géographiques"

#. Tag: programlisting
#: reference_relationship.xml:871
#, no-c-format
msgid ""
"SELECT ST_Intersects(\n"
"    'SRID=4326;LINESTRING(-43.23456 72.4567,-43.23456 72.4568)'::geography,\n"
"    'SRID=4326;POINT(-43.23456 72.4567772)'::geography\n"
"    );\n"
"\n"
" st_intersects\n"
"---------------\n"
"t"
msgstr ""
"SELECT ST_Intersects(\n"
"    'SRID=4326;LINESTRING(-43.23456 72.4567,-43.23456 72.4568)'::geography,\n"
"    'SRID=4326;POINT(-43.23456 72.4567772)'::geography\n"
"    );\n"
"\n"
" st_intersects\n"
"---------------\n"
"t"

#. Tag: para
#: reference_relationship.xml:875
#, no-c-format
msgid ", <xref linkend=\"ST_3DIntersects\"/>, <xref linkend=\"ST_Disjoint\"/>"
msgstr ", <xref linkend=\"ST_3DIntersects\"/>, <xref linkend=\"ST_Disjoint\"/>"

#. Tag: refname
#: reference_relationship.xml:881
#, no-c-format
msgid "ST_LineCrossingDirection"
msgstr "ST_LineCrossingDirection"

#. Tag: refpurpose
#: reference_relationship.xml:883
#, no-c-format
msgid "Returns a number indicating the crossing behavior of two LineStrings"
msgstr ""
"Renvoie un nombre indiquant le comportement de croisement de deux LineStrings"

#. Tag: funcprototype
#: reference_relationship.xml:888
#, no-c-format
msgid ""
"<funcdef>integer <function>ST_LineCrossingDirection</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>linestringA</parameter></"
"paramdef> <paramdef><type>geometry </type> <parameter>linestringB</"
"parameter></paramdef>"
msgstr ""
"<funcdef>integer <function>ST_LineCrossingDirection</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>linestringA</parameter></"
"paramdef> <paramdef><type>geometry </type> <parameter>linestringB</"
"parameter></paramdef>"

#. Tag: para
#: reference_relationship.xml:899
#, no-c-format
msgid ""
"Given two linestrings returns an integer between -3 and 3 indicating what "
"kind of crossing behavior exists between them. 0 indicates no crossing. This "
"is only supported for <varname>LINESTRING</varname>s."
msgstr ""
"En ayant 2 lignes en entrée, renvoie un nombre entier entre -3 et 3 "
"indiquant le type de croisement qui existe entre elles. 0 indique qu'il n'y "
"a pas de croisement. Cette fonction n'est prise en charge que pour les "
"<varname>LINESTRING</varname>s."

#. Tag: para
#: reference_relationship.xml:904
#, no-c-format
msgid "The crossing number has the following meaning:"
msgstr "Le numéro de croisement a la signification suivante :"

#. Tag: para
#: reference_relationship.xml:907
#, no-c-format
msgid "0: LINE NO CROSS"
msgstr "0 : LIGNE SANS CROISEMENT"

#. Tag: para
#: reference_relationship.xml:910
#, no-c-format
msgid "-1: LINE CROSS LEFT"
msgstr "-1 : LIGNE CROISÉE À GAUCHE"

#. Tag: para
#: reference_relationship.xml:913
#, no-c-format
msgid "1: LINE CROSS RIGHT"
msgstr "-1 : LIGNE CROISÉE À DROITE"

#. Tag: para
#: reference_relationship.xml:916
#, no-c-format
msgid "-2: LINE MULTICROSS END LEFT"
msgstr "-2 : LIGNE MULTICROISEMENT EXTRÉMITÉ GAUCHE"

#. Tag: para
#: reference_relationship.xml:919
#, no-c-format
msgid "2: LINE MULTICROSS END RIGHT"
msgstr "-2 : LIGNE MULTICROISEMENT EXTRÉMITÉ DROITE"

#. Tag: para
#: reference_relationship.xml:922
#, no-c-format
msgid "-3: LINE MULTICROSS END SAME FIRST LEFT"
msgstr "-3 : LIGNE MULTICROISEMENT FIN IDENTIQUE AU PREMIER GAUCHE"

#. Tag: para
#: reference_relationship.xml:925
#, no-c-format
msgid "3: LINE MULTICROSS END SAME FIRST RIGHT"
msgstr "-3 : LIGNE MULTICROISEMENT FIN IDENTIQUE AU PREMIER DROITE"

#. Tag: para
#: reference_relationship.xml:929
#, no-c-format
msgid "Availability: 1.4"
msgstr "Disponibilité : 1.4"

#. Tag: para
#: reference_relationship.xml:935
#, no-c-format
msgid ""
"<emphasis role=\"bold\">Example:</emphasis> LINE CROSS LEFT and LINE CROSS "
"RIGHT"
msgstr ""
"<emphasis role=\"bold\">Exemple:</emphasis> LIGNE CROISEE A GAUCHE et LIGNE "
"CROISEE A DROITE"

#. Tag: para
#: reference_relationship.xml:943 reference_relationship.xml:956
#: reference_relationship.xml:969
#, no-c-format
msgid "Blue: Line A; Green: Line B"
msgstr "Bleu : Ligne A ; Vert : Ligne B"

#. Tag: programlisting
#: reference_relationship.xml:946
#, no-c-format
msgid ""
"SELECT ST_LineCrossingDirection(lineA, lineB) As A_cross_B,\n"
"       ST_LineCrossingDirection(lineB, lineA) As B_cross_A\n"
"FROM (SELECT\n"
"  ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As lineA,\n"
"  ST_GeomFromText('LINESTRING (20 140, 71 74, 161 53)') As lineB\n"
"  ) As foo;\n"
"\n"
" A_cross_B | B_cross_A\n"
"-----------+-----------\n"
"        -1 |         1"
msgstr ""
"SELECT ST_LineCrossingDirection(lineA, lineB) As A_cross_B,\n"
"       ST_LineCrossingDirection(lineB, lineA) As B_cross_A\n"
"FROM (SELECT\n"
"  ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As lineA,\n"
"  ST_GeomFromText('LINESTRING (20 140, 71 74, 161 53)') As lineB\n"
"  ) As foo;\n"
"\n"
" A_cross_B | B_cross_A\n"
"-----------+-----------\n"
"        -1 |         1"

#. Tag: para
#: reference_relationship.xml:948
#, no-c-format
msgid ""
"<emphasis role=\"bold\">Example:</emphasis> LINE MULTICROSS END SAME FIRST "
"LEFT and LINE MULTICROSS END SAME FIRST RIGHT"
msgstr ""
"<emphasis role=\"bold\">Exemple:</emphasis> LIGNE MULTICROISEMENT FIN "
"IDENTIQUE AU PREMIER GAUCHE et LIGNE MULTICROISEMENT FIN IDENTIQUE AU "
"PREMIER DROITE"

#. Tag: programlisting
#: reference_relationship.xml:959
#, no-c-format
msgid ""
"SELECT ST_LineCrossingDirection(lineA, lineB) As A_cross_B,\n"
"       ST_LineCrossingDirection(lineB, lineA) As B_cross_A\n"
"FROM (SELECT\n"
" ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As lineA,\n"
" ST_GeomFromText('LINESTRING(171 154,20 140,71 74,161 53)') As lineB\n"
"  ) As foo;\n"
"\n"
" A_cross_B | B_cross_A\n"
"-----------+-----------\n"
"         3 |        -3"
msgstr ""
"SELECT ST_LineCrossingDirection(lineA, lineB) As A_cross_B,\n"
"       ST_LineCrossingDirection(lineB, lineA) As B_cross_A\n"
"FROM (SELECT\n"
" ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As lineA,\n"
" ST_GeomFromText('LINESTRING(171 154,20 140,71 74,161 53)') As lineB\n"
"  ) As foo;\n"
"\n"
" A_cross_B | B_cross_A\n"
"-----------+-----------\n"
"         3 |        -3"

#. Tag: para
#: reference_relationship.xml:961
#, no-c-format
msgid ""
"<emphasis role=\"bold\">Example:</emphasis> LINE MULTICROSS END LEFT and "
"LINE MULTICROSS END RIGHT"
msgstr ""
"<emphasis role=\"bold\">Exemple:</emphasis> LIGNE MULTICROISEMENT EXTRÉMITÉ "
"GAUCHE et LIGNE MULTICROISEMENT EXTRÉMITÉ DROITE"

#. Tag: programlisting
#: reference_relationship.xml:972
#, no-c-format
msgid ""
"SELECT ST_LineCrossingDirection(lineA, lineB) As A_cross_B,\n"
"       ST_LineCrossingDirection(lineB, lineA) As B_cross_A\n"
"FROM (SELECT\n"
"  ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As lineA,\n"
"  ST_GeomFromText('LINESTRING(5 90, 71 74, 20 140, 171 154)') As lineB\n"
"  ) As foo;\n"
"\n"
" A_cross_B | B_cross_A\n"
"-----------+-----------\n"
"        -2 |         2"
msgstr ""
"SELECT ST_LineCrossingDirection(lineA, lineB) As A_cross_B,\n"
"       ST_LineCrossingDirection(lineB, lineA) As B_cross_A\n"
"FROM (SELECT\n"
"  ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As lineA,\n"
"  ST_GeomFromText('LINESTRING(5 90, 71 74, 20 140, 171 154)') As lineB\n"
"  ) As foo;\n"
"\n"
" A_cross_B | B_cross_A\n"
"-----------+-----------\n"
"        -2 |         2"

#. Tag: para
#: reference_relationship.xml:974
#, no-c-format
msgid ""
"<emphasis role=\"bold\">Example:</emphasis> Finds all streets that cross"
msgstr ""
"<emphasis role=\"bold\">Exemple:</emphasis> Trouve toutes les rues qui se "
"croisent"

#. Tag: programlisting
#: reference_relationship.xml:977
#, no-c-format
msgid ""
"SELECT s1.gid, s2.gid, ST_LineCrossingDirection(s1.geom, s2.geom)\n"
"  FROM streets s1 CROSS JOIN streets s2\n"
"         ON (s1.gid != s2.gid AND s1.geom &amp;&amp; s2.geom )\n"
"WHERE ST_LineCrossingDirection(s1.geom, s2.geom) > 0;"
msgstr ""
"SELECT s1.gid, s2.gid, ST_LineCrossingDirection(s1.geom, s2.geom)\n"
"  FROM streets s1 CROSS JOIN streets s2\n"
"         ON (s1.gid != s2.gid AND s1.geom &amp;&amp; s2.geom )\n"
"WHERE ST_LineCrossingDirection(s1.geom, s2.geom) > 0;"

#. Tag: refname
#: reference_relationship.xml:988
#, no-c-format
msgid "ST_OrderingEquals"
msgstr "ST_OrderingEquals"

#. Tag: refpurpose
#: reference_relationship.xml:990
#, no-c-format
msgid ""
"Tests if two geometries represent the same geometry and have points in the "
"same directional order"
msgstr ""
"Teste si deux géométries représentent la même géométrie et ont des points "
"dans le même ordre directionnel"

#. Tag: funcprototype
#: reference_relationship.xml:995
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_OrderingEquals</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_OrderingEquals</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"

#. Tag: para
#: reference_relationship.xml:1006
#, no-c-format
msgid ""
"ST_OrderingEquals compares two geometries and returns t (TRUE) if the "
"geometries are equal and the coordinates are in the same order; otherwise it "
"returns f (FALSE)."
msgstr ""
"ST_OrderingEquals compare deux géométries et renvoie t (TRUE) si les "
"géométries sont égales et si les coordonnées sont dans le même ordre ; "
"sinon, il renvoie f (FALSE)."

#. Tag: para
#: reference_relationship.xml:1011
#, no-c-format
msgid ""
"This function is implemented as per the ArcSDE SQL specification rather than "
"SQL-MM. http://edndoc.esri.com/arcsde/9.1/sql_api/sqlapi3."
"htm#ST_OrderingEquals"
msgstr ""
"Cette fonction est mise en œuvre conformément à la spécification SQL "
"d'ArcSDE plutôt que SQL-MM. http://edndoc.esri.com/arcsde/9.1/sql_api/"
"sqlapi3.htm#ST_OrderingEquals"

#. Tag: para
#: reference_relationship.xml:1015
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 5.1.43"
msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.43"

#. Tag: programlisting
#: reference_relationship.xml:1021
#, no-c-format
msgid ""
"SELECT ST_OrderingEquals(ST_GeomFromText('LINESTRING(0 0, 10 10)'),\n"
"    ST_GeomFromText('LINESTRING(0 0, 5 5, 10 10)'));\n"
" st_orderingequals\n"
"-----------\n"
" f\n"
"(1 row)\n"
"\n"
"SELECT ST_OrderingEquals(ST_GeomFromText('LINESTRING(0 0, 10 10)'),\n"
"    ST_GeomFromText('LINESTRING(0 0, 0 0, 10 10)'));\n"
" st_orderingequals\n"
"-----------\n"
" t\n"
"(1 row)\n"
"\n"
"SELECT ST_OrderingEquals(ST_Reverse(ST_GeomFromText('LINESTRING(0 0, 10 "
"10)')),\n"
"    ST_GeomFromText('LINESTRING(0 0, 0 0, 10 10)'));\n"
" st_orderingequals\n"
"-----------\n"
" f\n"
"(1 row)"
msgstr ""
"SELECT ST_OrderingEquals(ST_GeomFromText('LINESTRING(0 0, 10 10)'),\n"
"    ST_GeomFromText('LINESTRING(0 0, 5 5, 10 10)'));\n"
" st_orderingequals\n"
"-----------\n"
" f\n"
"(1 row)\n"
"\n"
"SELECT ST_OrderingEquals(ST_GeomFromText('LINESTRING(0 0, 10 10)'),\n"
"    ST_GeomFromText('LINESTRING(0 0, 0 0, 10 10)'));\n"
" st_orderingequals\n"
"-----------\n"
" t\n"
"(1 row)\n"
"\n"
"SELECT ST_OrderingEquals(ST_Reverse(ST_GeomFromText('LINESTRING(0 0, 10 "
"10)')),\n"
"    ST_GeomFromText('LINESTRING(0 0, 0 0, 10 10)'));\n"
" st_orderingequals\n"
"-----------\n"
" f\n"
"(1 row)"

#. Tag: para
#: reference_relationship.xml:1025
#, no-c-format
msgid ", <xref linkend=\"ST_Equals\"/>, <xref linkend=\"ST_Reverse\"/>"
msgstr ", <xref linkend=\"ST_Equals\"/>, <xref linkend=\"ST_Reverse\"/>"

#. Tag: refname
#: reference_relationship.xml:1031
#, no-c-format
msgid "ST_Overlaps"
msgstr "ST_Overlaps"

#. Tag: refpurpose
#: reference_relationship.xml:1033
#, no-c-format
msgid ""
"Tests if two geometries have the same dimension and intersect, but each has "
"at least one point not in the other"
msgstr ""
"Teste si deux géométries ont la même dimension et se croisent, mais si "
"chacune a au moins un point qui n'est pas dans l'autre"

#. Tag: funcprototype
#: reference_relationship.xml:1038
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_Overlaps</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_Overlaps</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"

#. Tag: para
#: reference_relationship.xml:1049
#, no-c-format
msgid ""
"Returns TRUE if geometry A and B \"spatially overlap\". Two geometries "
"overlap if they have the same dimension, their interiors intersect in that "
"dimension. and each has at least one point inside the other (or "
"equivalently, neither one covers the other). The overlaps relation is "
"symmetric and irreflexive."
msgstr ""

#. Tag: para
#: reference_relationship.xml:1057
#, no-c-format
msgid ""
"In mathematical terms: <emphasis>ST_Overlaps(A, B) ⇔ ( dim(A) = dim(B) = "
"dim( Int(A) ⋂ Int(B) )) ∧ (A ⋂ B ≠ A) ∧ (A ⋂ B ≠ B) </emphasis>"
msgstr ""

#. Tag: para
#: reference_relationship.xml:1060
#, no-c-format
msgid ""
"&index_aware; To avoid index use, use the function <function>_ST_Overlaps</"
"function>."
msgstr ""
"&index_aware; Pour éviter l'utilisation d'un index, utilisez la fonction "
"<function>_ST_Overlaps</function>."

#. Tag: para
#: reference_relationship.xml:1072 reference_relationship.xml:1266
#: reference_relationship.xml:1433
#, no-c-format
msgid "&sfs_compliant; s2.1.1.2 // s2.1.13.3"
msgstr "&sfs_compliant; s2.1.1.2 // s2.1.13.3"

#. Tag: para
#: reference_relationship.xml:1073
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 5.1.32"
msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.32"

#. Tag: para
#: reference_relationship.xml:1078
#, no-c-format
msgid ""
"<function>ST_Overlaps</function> returns <varname>TRUE</varname> in the "
"following situations:"
msgstr ""
"<function>ST_Overlaps</function> renvoie <varname>TRUE</varname> dans les "
"situations suivantes :"

#. Tag: para
#: reference_relationship.xml:1089
#, no-c-format
msgid "<varname>MULTIPOINT</varname> / <varname>MULTIPOINT</varname>"
msgstr "<varname>MULTIPOINT</varname> / <varname>MULTIPOINT</varname>"

#. Tag: para
#: reference_relationship.xml:1121
#, no-c-format
msgid ""
"A Point on a LineString is contained, but since it has lower dimension it "
"does not overlap or cross."
msgstr ""
"Un point sur une LineString est contenu, mais comme il a une dimension "
"inférieure, il ne se chevauche pas et ne se croise pas."

#. Tag: programlisting
#: reference_relationship.xml:1123
#, no-c-format
msgid ""
"SELECT ST_Overlaps(a,b) AS overlaps,       ST_Crosses(a,b) AS crosses,\n"
"       ST_Intersects(a, b) AS intersects,  ST_Contains(b,a) AS b_contains_a\n"
"FROM (SELECT ST_GeomFromText('POINT (100 100)') As a,\n"
"             ST_GeomFromText('LINESTRING (30 50, 40 160, 160 40, 180 160)')  "
"AS b) AS t\n"
"\n"
"overlaps | crosses | intersects | b_contains_a\n"
"---------+----------------------+--------------\n"
"f        | f       | t          | t"
msgstr ""
"SELECT ST_Overlaps(a,b) AS overlaps,       ST_Crosses(a,b) AS crosses,\n"
"       ST_Intersects(a, b) AS intersects,  ST_Contains(b,a) AS b_contains_a\n"
"FROM (SELECT ST_GeomFromText('POINT (100 100)') As a,\n"
"             ST_GeomFromText('LINESTRING (30 50, 40 160, 160 40, 180 160)')  "
"AS b) AS t\n"
"\n"
"overlaps | crosses | intersects | b_contains_a\n"
"---------+----------------------+--------------\n"
"f        | f       | t          | t"

#. Tag: para
#: reference_relationship.xml:1131
#, no-c-format
msgid ""
"A LineString that partly covers a Polygon intersects and crosses, but does "
"not overlap since it has different dimension."
msgstr ""
"Une chaîne de lignes qui recouvre partiellement un polygone l'intersecte et "
"le traverse, mais ne se chevauche pas car elle a des dimensions différentes."

#. Tag: programlisting
#: reference_relationship.xml:1133
#, no-c-format
msgid ""
"SELECT ST_Overlaps(a,b) AS overlaps,        ST_Crosses(a,b) AS crosses,\n"
"       ST_Intersects(a, b) AS intersects,   ST_Contains(a,b) AS contains\n"
"FROM (SELECT ST_GeomFromText('POLYGON ((40 170, 90 30, 180 100, 40 170))') "
"AS a,\n"
"             ST_GeomFromText('LINESTRING(10 10, 190 190)') AS b) AS t;\n"
"\n"
" overlap | crosses | intersects | contains\n"
"---------+---------+------------+--------------\n"
" f       | t       | t          | f"
msgstr ""
"SELECT ST_Overlaps(a,b) AS overlaps,        ST_Crosses(a,b) AS crosses,\n"
"       ST_Intersects(a, b) AS intersects,   ST_Contains(a,b) AS contains\n"
"FROM (SELECT ST_GeomFromText('POLYGON ((40 170, 90 30, 180 100, 40 170))') "
"AS a,\n"
"             ST_GeomFromText('LINESTRING(10 10, 190 190)') AS b) AS t;\n"
"\n"
" overlap | crosses | intersects | contains\n"
"---------+---------+------------+--------------\n"
" f       | t       | t          | f"

#. Tag: para
#: reference_relationship.xml:1141
#, no-c-format
msgid ""
"Two Polygons that intersect but with neither contained by the other overlap, "
"but do not cross because their intersection has the same dimension."
msgstr ""
"Deux polygones qui se croisent mais dont aucun n'est contenu par l'autre se "
"chevauchent, mais ne se croisent pas car leur intersection a la même "
"dimension."

#. Tag: programlisting
#: reference_relationship.xml:1143
#, no-c-format
msgid ""
"SELECT ST_Overlaps(a,b) AS overlaps,       ST_Crosses(a,b) AS crosses,\n"
"       ST_Intersects(a, b) AS intersects,  ST_Contains(b, a) AS "
"b_contains_a,\n"
"       ST_Dimension(a) AS dim_a, ST_Dimension(b) AS dim_b,\n"
"       ST_Dimension(ST_Intersection(a,b)) AS dim_int\n"
"FROM (SELECT ST_GeomFromText('POLYGON ((40 170, 90 30, 180 100, 40 170))') "
"AS a,\n"
"             ST_GeomFromText('POLYGON ((110 180, 20 60, 130 90, 110 180))') "
"AS b) As t;\n"
"\n"
" overlaps | crosses | intersects | b_contains_a | dim_a | dim_b | dim_int\n"
"----------+---------+------------+--------------+-------+-------"
"+-----------\n"
" t        | f       | t          | f            |     2 |     2 |       2"
msgstr ""
"SELECT ST_Overlaps(a,b) AS overlaps,       ST_Crosses(a,b) AS crosses,\n"
"       ST_Intersects(a, b) AS intersects,  ST_Contains(b, a) AS "
"b_contains_a,\n"
"       ST_Dimension(a) AS dim_a, ST_Dimension(b) AS dim_b,\n"
"       ST_Dimension(ST_Intersection(a,b)) AS dim_int\n"
"FROM (SELECT ST_GeomFromText('POLYGON ((40 170, 90 30, 180 100, 40 170))') "
"AS a,\n"
"             ST_GeomFromText('POLYGON ((110 180, 20 60, 130 90, 110 180))') "
"AS b) As t;\n"
"\n"
" overlaps | crosses | intersects | b_contains_a | dim_a | dim_b | dim_int\n"
"----------+---------+------------+--------------+-------+-------"
"+-----------\n"
" t        | f       | t          | f            |     2 |     2 |       2"

#. Tag: para
#: reference_relationship.xml:1151
#, no-c-format
msgid ""
", <xref linkend=\"ST_Crosses\"/>, <xref linkend=\"ST_Dimension\"/>, <xref "
"linkend=\"ST_Intersects\"/>"
msgstr ""
", <xref linkend=\"ST_Crosses\"/>, <xref linkend=\"ST_Dimension\"/>, <xref "
"linkend=\"ST_Intersects\"/>"

#. Tag: refname
#: reference_relationship.xml:1157
#, no-c-format
msgid "ST_Relate"
msgstr "ST_Relate"

#. Tag: refpurpose
#: reference_relationship.xml:1159
#, no-c-format
msgid ""
"Tests if two geometries have a topological relationship matching an "
"Intersection Matrix pattern, or computes their Intersection Matrix"
msgstr ""
"Teste si deux géométries ont une relation topologique correspondant à un "
"modèle de matrice d'intersection, ou calcule leur matrice d'intersection"

#. Tag: funcsynopsis
#: reference_relationship.xml:1166
#, no-c-format
msgid ""
"<funcprototype> <funcdef>boolean <function>ST_Relate</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef> "
"<paramdef><type>text </type> <parameter>intersectionMatrixPattern</"
"parameter></paramdef> </funcprototype> <funcprototype> <funcdef>text "
"<function>ST_Relate</function></funcdef> <paramdef><type>geometry </type> "
"<parameter>geomA</parameter></paramdef> <paramdef><type>geometry </type> "
"<parameter>geomB</parameter></paramdef> </funcprototype> <funcprototype> "
"<funcdef>text <function>ST_Relate</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef> "
"<paramdef><type>integer </type> <parameter>boundaryNodeRule</parameter></"
"paramdef> </funcprototype>"
msgstr ""
"<funcprototype> <funcdef>boolean <function>ST_Relate</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef> "
"<paramdef><type>text </type> <parameter>intersectionMatrixPattern</"
"parameter></paramdef> </funcprototype> <funcprototype> <funcdef>text "
"<function>ST_Relate</function></funcdef> <paramdef><type>geometry </type> "
"<parameter>geomA</parameter></paramdef> <paramdef><type>geometry </type> "
"<parameter>geomB</parameter></paramdef> </funcprototype> <funcprototype> "
"<funcdef>text <function>ST_Relate</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef> "
"<paramdef><type>integer </type> <parameter>boundaryNodeRule</parameter></"
"paramdef> </funcprototype>"

#. Tag: para
#: reference_relationship.xml:1192
#, no-c-format
msgid ""
"These functions allow testing and evaluating the spatial (topological) "
"relationship between two geometries, as defined by the <ulink url=\"http://"
"en.wikipedia.org/wiki/DE-9IM\">Dimensionally Extended 9-Intersection Model</"
"ulink> (DE-9IM)."
msgstr ""
"Ces fonctions permettent de tester et d'évaluer la relation spatiale "
"(topologique) entre deux géométries, telle que définie par le <ulink "
"url=\"http://en.wikipedia.org/wiki/DE-9IM\">Dimensionally Extended 9-"
"Intersection Model</ulink> (DE-9IM)."

#. Tag: para
#: reference_relationship.xml:1196
#, no-c-format
msgid ""
"The DE-9IM is specified as a 9-element matrix indicating the dimension of "
"the intersections between the Interior, Boundary and Exterior of two "
"geometries. It is represented by a 9-character text string using the symbols "
"'F', '0', '1', '2' (e.g. <code>'FF1FF0102'</code>)."
msgstr ""
"Le DE-9IM est une matrice à 9 éléments indiquant la dimension des "
"intersections entre l'intérieur, la frontière et l'extérieur de deux "
"géométries. Elle est représentée par une chaîne de texte de 9 caractères "
"utilisant les symboles \"F\", \"0\", \"1\", \"2\" (par exemple, "
"<code>'FF1FF0102'</code>)."

#. Tag: para
#: reference_relationship.xml:1202
#, no-c-format
msgid ""
"A specific kind of spatial relationship can be tested by matching the "
"intersection matrix to an <emphasis>intersection matrix pattern</emphasis>. "
"Patterns can include the additional symbols 'T' (meaning \"intersection is "
"non-empty\") and '*' (meaning \"any value\"). Common spatial relationships "
"are provided by the named functions <xref linkend=\"ST_Contains\"/>, <xref "
"linkend=\"ST_ContainsProperly\"/>, <xref linkend=\"ST_Covers\"/>, <xref "
"linkend=\"ST_CoveredBy\"/>, <xref linkend=\"ST_Crosses\"/>, <xref "
"linkend=\"ST_Disjoint\"/>, <xref linkend=\"ST_Equals\"/>, <xref "
"linkend=\"ST_Intersects\"/>, <xref linkend=\"ST_Overlaps\"/>, <xref "
"linkend=\"ST_Touches\"/>, and <xref linkend=\"ST_Within\"/>. Using an "
"explicit pattern allows testing multiple conditions of intersects, crosses, "
"etc in one step. It also allows testing spatial relationships which do not "
"have a named spatial relationship function. For example, the relationship "
"\"Interior-Intersects\" has the DE-9IM pattern <code>T********</code>, which "
"is not evaluated by any named predicate."
msgstr ""
"Un type spécifique de relation spatiale peut être testé en faisant "
"correspondre la matrice d'intersection à un <emphasis>motif de matrice "
"d'intersection</emphasis>. Les motifs peuvent inclure les symboles "
"supplémentaires \"T\" (signifiant \"l'intersection est non vide\") et "
"\"*\" (signifiant \"n'importe quelle valeur\"). Les relations spatiales "
"communes sont fournies par les fonctions nommées <xref "
"linkend=\"ST_Contains\"/>, <xref linkend=\"ST_ContainsProperly\"/>, <xref "
"linkend=\"ST_Covers\"/>, <xref linkend=\"ST_CoveredBy\"/>, <xref "
"linkend=\"ST_Crosses\"/>, <xref linkend=\"ST_Disjoint\"/>, <xref "
"linkend=\"ST_Equals\"/>, <xref linkend=\"ST_Intersects\"/>, <xref "
"linkend=\"ST_Overlaps\"/>, <xref linkend=\"ST_Touches\"/>, et <xref "
"linkend=\"ST_Within\"/>. L'utilisation d'un modèle explicite permet de "
"tester plusieurs conditions d'intersection, de croisement, etc. en une seule "
"étape. Elle permet également de tester des relations spatiales qui n'ont pas "
"de fonction de relation spatiale nommée. Par exemple, la relation \"Interior-"
"Intersects\" possède le motif DE-9IM <code>T********</code>, qui n'est "
"évalué par aucun prédicat nommé."

#. Tag: para
#: reference_relationship.xml:1218 reference_relationship.xml:1350
#, no-c-format
msgid "For more information refer to <xref linkend=\"eval_spatial_rel\"/>."
msgstr "Pour plus d'informations, voir <xref linkend=\"eval_spatial_rel\"/>."

#. Tag: para
#: reference_relationship.xml:1222
#, no-c-format
msgid ""
"<emphasis role=\"bold\">Variant 1:</emphasis> Tests if two geometries are "
"spatially related according to the given <varname>intersectionMatrixPattern</"
"varname>."
msgstr ""
"<emphasis role=\"bold\">Variante 1:</emphasis> Teste si deux géométries sont "
"spatialement liées selon le <varname>intersectionMatrixPattern</varname> "
"donné."

#. Tag: para
#: reference_relationship.xml:1226
#, no-c-format
msgid ""
"Unlike most of the named spatial relationship predicates, this does NOT "
"automatically include an index call. The reason is that some relationships "
"are true for geometries which do NOT intersect (e.g. Disjoint). If you are "
"using a relationship pattern that requires intersection, then include the "
"&amp;&amp; index call."
msgstr ""
"Contrairement à la plupart des prédicats de relations spatiales nommées, ce "
"prédicat n'inclut PAS automatiquement un appel d'index. La raison en est que "
"certaines relations sont vraies pour des géométries qui ne s'intersectent "
"PAS (par exemple Disjoint). Si vous utilisez un modèle de relation qui "
"nécessite une intersection, incluez l'appel à l'index &amp;&amp;."

#. Tag: para
#: reference_relationship.xml:1234
#, no-c-format
msgid ""
"It is better to use a named relationship function if available, since they "
"automatically use a spatial index where one exists. Also, they may implement "
"performance optimizations which are not available with full relate evalation."
msgstr ""
"Il est préférable d'utiliser une fonction de relation nommée si elle est "
"disponible, car elle utilise automatiquement un index spatial lorsqu'il "
"existe. En outre, elles peuvent mettre en œuvre des optimisations de "
"performance qui ne sont pas disponibles avec l'évaluation de la relation "
"complète."

#. Tag: para
#: reference_relationship.xml:1240
#, no-c-format
msgid ""
"<emphasis role=\"bold\">Variant 2:</emphasis> Returns the DE-9IM matrix "
"string for the spatial relationship between the two input geometries. The "
"matrix string can be tested for matching a DE-9IM pattern using <xref "
"linkend=\"ST_RelateMatch\"/>."
msgstr ""
"<emphasis role=\"bold\">Variante 2:</emphasis> Renvoie la chaîne matricielle "
"DE-9IM pour la relation spatiale entre les deux géométries d'entrée. La "
"chaîne matricielle peut être testée pour vérifier si elle correspond à un "
"modèle DE-9IM en utilisant <xref linkend=\"ST_RelateMatch\"/>."

#. Tag: para
#: reference_relationship.xml:1245
#, no-c-format
msgid ""
"<emphasis role=\"bold\">Variant 3:</emphasis> Like variant 2, but allows "
"specifying a <emphasis role=\"bold\">Boundary Node Rule</emphasis>. A "
"boundary node rule allows finer control over whether the endpoints of "
"MultiLineStrings are considered to lie in the DE-9IM Interior or Boundary. "
"The <varname>boundaryNodeRule</varname> values are:"
msgstr ""
"<emphasis role=\"bold\">Variante 3:</emphasis> Comme la variante 2, mais "
"permet de spécifier une <emphasis role=\"bold\">Boundary Node Rule</"
"emphasis>. Une boundary node rule permet de contrôler plus finement si les "
"extrémités des multilignes sont considérées comme se situant à l'intérieur "
"ou à la limite du DE-9IM. Les valeurs de <varname>boundaryNodeRule</varname> "
"sont les suivantes :"

#. Tag: para
#: reference_relationship.xml:1252
#, no-c-format
msgid ""
"<code>1</code>: <emphasis role=\"bold\">OGC-Mod2</emphasis> - line endpoints "
"are in the Boundary if they occur an odd number of times. This is the rule "
"defined by the OGC SFS standard, and is the default for <function>ST_Relate</"
"function>."
msgstr ""
"<code>1</code> : <emphasis role=\"bold\">OGC-Mod2</emphasis> - les "
"extrémités des lignes sont dans la frontière si elles apparaissent un nombre "
"impair de fois. C'est la règle définie par la norme SFS de l'OGC, et c'est "
"la valeur par défaut de la <function>ST_Relate</function>."

#. Tag: para
#: reference_relationship.xml:1255
#, no-c-format
msgid ""
"<code>2</code>: <emphasis role=\"bold\">Endpoint</emphasis> - all endpoints "
"are in the Boundary."
msgstr ""
"<code>2</code> : <emphasis role=\"bold\">Endpoint</emphasis> - tous les "
"points d'extrémité sont dans la frontière."

#. Tag: para
#: reference_relationship.xml:1257
#, no-c-format
msgid ""
"<code>3</code>: <emphasis role=\"bold\">MultivalentEndpoint</emphasis> - "
"endpoints are in the Boundary if they occur more than once. In other words, "
"the boundary is all the \"attached\" or \"inner\" endpoints (but not the "
"\"unattached/outer\" ones)."
msgstr ""
"<code>3</code> : <emphasis role=\"bold\">MultivalentEndpoint</emphasis> - "
"les points d'extrémité sont dans la frontière s'ils apparaissent plus d'une "
"fois. En d'autres termes, la frontière est constituée de tous les points "
"d'extrémité \"attachés\" ou \"internes\" (mais pas des points d'extrémité "
"\"non attachés/externes\")."

#. Tag: para
#: reference_relationship.xml:1260
#, no-c-format
msgid ""
"<code>4</code>: <emphasis role=\"bold\">MonovalentEndpoint</emphasis> - "
"endpoints are in the Boundary if they occur only once. In other words, the "
"boundary is all the \"unattached\" or \"outer\" endpoints."
msgstr ""
"<code>4</code> : <emphasis role=\"bold\">MonovalentEndpoint</emphasis> - les "
"points d'extrémité sont dans la frontière s'ils n'apparaissent qu'une seule "
"fois. En d'autres termes, la frontière est constituée de tous les points "
"d'extrémité \"non attachés\" ou \"extérieurs\"."

#. Tag: para
#: reference_relationship.xml:1265
#, no-c-format
msgid "This function is not in the OGC spec, but is implied. see s2.1.13.2"
msgstr ""
"Cette fonction ne figure pas dans la spécification de l'OGC, mais elle est "
"implicite. voir s2.1.13.2"

#. Tag: para
#: reference_relationship.xml:1267
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 5.1.25"
msgstr "&sqlmm_compliant; SQL-MM 3 : 5.1.25"

#. Tag: para
#: reference_relationship.xml:1269
#, no-c-format
msgid "Enhanced: 2.0.0 - added support for specifying boundary node rule."
msgstr ""
"Amélioration : 2.0.0 - ajout de la prise en charge de la spécification de "
"boundary node rule."

#. Tag: para
#: reference_relationship.xml:1280
#, no-c-format
msgid "Using the boolean-valued function to test spatial relationships."
msgstr ""
"Utilisation de la fonction booléenne pour tester les relations spatiales."

#. Tag: programlisting
#: reference_relationship.xml:1281
#, no-c-format
msgid ""
"SELECT ST_Relate('POINT(1 2)', ST_Buffer( 'POINT(1 2)', 2), '0FFFFF212');\n"
"st_relate\n"
"-----------\n"
"t\n"
"\n"
"SELECT ST_Relate(POINT(1 2)', ST_Buffer( 'POINT(1 2)', 2), '*FF*FF212');\n"
"st_relate\n"
"-----------\n"
"t"
msgstr ""
"SELECT ST_Relate('POINT(1 2)', ST_Buffer( 'POINT(1 2)', 2), '0FFFFF212');\n"
"st_relate\n"
"-----------\n"
"t\n"
"\n"
"SELECT ST_Relate(POINT(1 2)', ST_Buffer( 'POINT(1 2)', 2), '*FF*FF212');\n"
"st_relate\n"
"-----------\n"
"t"

#. Tag: para
#: reference_relationship.xml:1283
#, no-c-format
msgid ""
"Testing a custom spatial relationship pattern as a query condition, with "
"<code>&amp;&amp;</code> to enable using a spatial index."
msgstr ""
"Test d'un modèle de relation spatiale personnalisé comme condition de "
"requête, avec <code>&amp;&amp;</code> pour permettre l'utilisation d'un "
"index spatial."

#. Tag: programlisting
#: reference_relationship.xml:1285
#, no-c-format
msgid ""
"-- Find compounds that properly intersect (not just touch) a poly (Interior "
"Intersects)\n"
"\n"
"SELECT c.* , p.name As poly_name\n"
"    FROM polys AS p\n"
"    INNER JOIN compounds As c\n"
"          ON c.geom &amp;&amp; p.geom\n"
"             AND ST_Relate(p.geom, c.geom,'T********');"
msgstr ""
"-- Trouver les composés qui intersectent correctement (et pas seulement qui "
"touchent) un poly (Interior Intersects)\n"
"\n"
"SELECT c.* , p.name As poly_name\n"
"    FROM polys AS p\n"
"    INNER JOIN compounds As c\n"
"          ON c.geom &amp;&amp; p.geom\n"
"             AND ST_Relate(p.geom, c.geom,'T********');"

#. Tag: para
#: reference_relationship.xml:1287
#, no-c-format
msgid "Computing the intersection matrix for spatial relationships."
msgstr "Calcul de la matrice d'intersection pour les relations spatiales."

#. Tag: programlisting
#: reference_relationship.xml:1288
#, no-c-format
msgid ""
"SELECT ST_Relate( 'POINT(1 2)',\n"
"                  ST_Buffer( 'POINT(1 2)', 2));\n"
"-----------\n"
"0FFFFF212\n"
"\n"
"SELECT ST_Relate( 'LINESTRING(1 2, 3 4)',\n"
"                  'LINESTRING(5 6, 7 8)' );\n"
"-----------\n"
"FF1FF0102"
msgstr ""
"SELECT ST_Relate( 'POINT(1 2)',\n"
"                  ST_Buffer( 'POINT(1 2)', 2));\n"
"-----------\n"
"0FFFFF212\n"
"\n"
"SELECT ST_Relate( 'LINESTRING(1 2, 3 4)',\n"
"                  'LINESTRING(5 6, 7 8)' );\n"
"-----------\n"
"FF1FF0102"

#. Tag: para
#: reference_relationship.xml:1290
#, no-c-format
msgid ""
"Using different Boundary Node Rules to compute the spatial relationship "
"between a LineString and a MultiLineString with a duplicate endpoint "
"<code>(3 3)</code>:"
msgstr ""
"Utilisation de différentes Boundary Node Rules pour calculer la relation "
"spatiale entre une LineString et une MultiLineString avec une extrémité "
"dupliquée <code>(3 3)</code> :"

#. Tag: para
#: reference_relationship.xml:1294
#, no-c-format
msgid ""
"Using the <emphasis role=\"bold\">OGC-Mod2</emphasis> rule (1) the duplicate "
"endpoint is in the <emphasis role=\"bold\">interior</emphasis> of the "
"MultiLineString, so the DE-9IM matrix entry [aB:bI] is <code>0</code> and "
"[aB:bB] is <code>F</code>."
msgstr ""
"En utilisant la règle <emphasis role=\"bold\">OGC-Mod2</emphasis> (1), "
"l'extrémité dupliquée se trouve dans l' <emphasis role=\"bold\">intérieur</"
"emphasis> de la MultiLineString, de sorte que l'entrée de la matrice DE-9IM "
"[aB:bI] est <code>0</code> et [aB:bB] est <code>F</code>."

#. Tag: para
#: reference_relationship.xml:1298
#, no-c-format
msgid ""
"Using the <emphasis role=\"bold\">Endpoint</emphasis> rule (2) the duplicate "
"endpoint is in the <emphasis role=\"bold\">boundary</emphasis> of the "
"MultiLineString, so the DE-9IM matrix entry [aB:bI] is <code>F</code> and "
"[aB:bB] is <code>0</code>."
msgstr ""
"En utilisant la règle <emphasis role=\"bold\">Endpoint</emphasis> (2), "
"l'extrémité dupliquée se trouve dans la <emphasis role=\"bold\">limite</"
"emphasis> de la MultiLineString, de sorte que l'entrée de la matrice DE-9IM "
"[aB:bI] est <code>F</code> et [aB:bB] est <code>0</code>."

#. Tag: programlisting
#: reference_relationship.xml:1303
#, no-c-format
msgid ""
"WITH data AS (SELECT\n"
"  'LINESTRING(1 1, 3 3)'::geometry AS a_line,\n"
"  'MULTILINESTRING((3 3, 3 5), (3 3, 5 3))':: geometry AS b_multiline\n"
")\n"
"SELECT ST_Relate( a_line, b_multiline, 1) AS bnr_mod2,\n"
"       ST_Relate( a_line, b_multiline, 2) AS bnr_endpoint\n"
"    FROM data;\n"
"\n"
" bnr_mod2  | bnr_endpoint\n"
"-----------+--------------\n"
" FF10F0102 | FF1F00102"
msgstr ""
"WITH data AS (SELECT\n"
"  'LINESTRING(1 1, 3 3)'::geometry AS a_line,\n"
"  'MULTILINESTRING((3 3, 3 5), (3 3, 5 3))':: geometry AS b_multiline\n"
")\n"
"SELECT ST_Relate( a_line, b_multiline, 1) AS bnr_mod2,\n"
"       ST_Relate( a_line, b_multiline, 2) AS bnr_endpoint\n"
"    FROM data;\n"
"\n"
" bnr_mod2  | bnr_endpoint\n"
"-----------+--------------\n"
" FF10F0102 | FF1F00102"

#. Tag: para
#: reference_relationship.xml:1312
#, no-c-format
msgid ""
", <xref linkend=\"ST_RelateMatch\"/>, <xref linkend=\"ST_Contains\"/>, <xref "
"linkend=\"ST_ContainsProperly\"/>, <xref linkend=\"ST_Covers\"/>, <xref "
"linkend=\"ST_CoveredBy\"/>, <xref linkend=\"ST_Crosses\"/>, <xref "
"linkend=\"ST_Disjoint\"/>, <xref linkend=\"ST_Equals\"/>, <xref "
"linkend=\"ST_Intersects\"/>, <xref linkend=\"ST_Overlaps\"/>, <xref "
"linkend=\"ST_Touches\"/>, <xref linkend=\"ST_Within\"/>"
msgstr ""
", <xref linkend=\"ST_RelateMatch\"/>, <xref linkend=\"ST_Contains\"/>, <xref "
"linkend=\"ST_ContainsProperly\"/>, <xref linkend=\"ST_Covers\"/>, <xref "
"linkend=\"ST_CoveredBy\"/>, <xref linkend=\"ST_Crosses\"/>, <xref "
"linkend=\"ST_Disjoint\"/>, <xref linkend=\"ST_Equals\"/>, <xref "
"linkend=\"ST_Intersects\"/>, <xref linkend=\"ST_Overlaps\"/>, <xref "
"linkend=\"ST_Touches\"/>, <xref linkend=\"ST_Within\"/>"

#. Tag: refname
#: reference_relationship.xml:1325
#, no-c-format
msgid "ST_RelateMatch"
msgstr "ST_RelateMatch"

#. Tag: refpurpose
#: reference_relationship.xml:1327
#, no-c-format
msgid ""
"Tests if a DE-9IM Intersection Matrix matches an Intersection Matrix pattern"
msgstr ""
"Teste si une matrice d'intersection DE-9IM correspond à un modèle de matrice "
"d'intersection"

#. Tag: funcprototype
#: reference_relationship.xml:1333
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_RelateMatch</function></funcdef> "
"<paramdef><type>text </type> <parameter>intersectionMatrix</parameter></"
"paramdef> <paramdef><type>text </type> <parameter>intersectionMatrixPattern</"
"parameter></paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_RelateMatch</function></funcdef> "
"<paramdef><type>text </type> <parameter>intersectionMatrix</parameter></"
"paramdef> <paramdef><type>text </type> <parameter>intersectionMatrixPattern</"
"parameter></paramdef>"

#. Tag: para
#: reference_relationship.xml:1344
#, no-c-format
msgid ""
"Tests if a <ulink url=\"http://en.wikipedia.org/wiki/DE-9IM\">Dimensionally "
"Extended 9-Intersection Model</ulink> (DE-9IM) <varname>intersectionMatrix</"
"varname> value satisfies an <varname>intersectionMatrixPattern</varname>. "
"Intersection matrix values can be computed by <xref linkend=\"ST_Relate\"/>."
msgstr ""
"Teste si une <ulink url=\"http://en.wikipedia.org/wiki/"
"DE-9IM\">Dimensionally Extended 9-Intersection Model</ulink> (DE-9IM) "
"<varname>intersectionMatrix</varname> satisfait un "
"<varname>intersectionMatrixPattern</varname>. Les valeurs de la matrice "
"d'intersection peuvent être calculées par <xref linkend=\"ST_Relate\"/>."

#. Tag: programlisting
#: reference_relationship.xml:1361
#, no-c-format
msgid ""
"SELECT ST_RelateMatch('101202FFF', 'TTTTTTFFF') ;\n"
"-- result --\n"
"t"
msgstr ""
"SELECT ST_RelateMatch('101202FFF', 'TTTTTTFFF') ;\n"
"-- résultat --\n"
"t"

#. Tag: para
#: reference_relationship.xml:1362
#, no-c-format
msgid ""
"Patterns for common spatial relationships matched against intersection "
"matrix values, for a line in various positions relative to a polygon"
msgstr ""
"Modèles de relations spatiales communes mis en correspondance avec les "
"valeurs de la matrice d'intersection, pour une ligne dans différentes "
"positions par rapport à un polygone"

#. Tag: programlisting
#: reference_relationship.xml:1365
#, no-c-format
msgid ""
"SELECT pat.name AS relationship, pat.val AS pattern,\n"
"       mat.name AS position, mat.val AS matrix,\n"
"       ST_RelateMatch(mat.val, pat.val) AS match\n"
"    FROM (VALUES ( 'Equality', 'T1FF1FFF1' ),\n"
"                 ( 'Overlaps', 'T*T***T**' ),\n"
"                 ( 'Within',   'T*F**F***' ),\n"
"                 ( 'Disjoint', 'FF*FF****' )) AS pat(name,val)\n"
"    CROSS JOIN\n"
"        (VALUES  ('non-intersecting', 'FF1FF0212'),\n"
"                 ('overlapping',      '1010F0212'),\n"
"                 ('inside',           '1FF0FF212')) AS mat(name,val);\n"
"\n"
" relationship |  pattern  |     position     |  matrix   | match\n"
"--------------+-----------+------------------+-----------+-------\n"
" Equality     | T1FF1FFF1 | non-intersecting | FF1FF0212 | f\n"
" Equality     | T1FF1FFF1 | overlapping      | 1010F0212 | f\n"
" Equality     | T1FF1FFF1 | inside           | 1FF0FF212 | f\n"
" Overlaps     | T*T***T** | non-intersecting | FF1FF0212 | f\n"
" Overlaps     | T*T***T** | overlapping      | 1010F0212 | t\n"
" Overlaps     | T*T***T** | inside           | 1FF0FF212 | f\n"
" Within       | T*F**F*** | non-intersecting | FF1FF0212 | f\n"
" Within       | T*F**F*** | overlapping      | 1010F0212 | f\n"
" Within       | T*F**F*** | inside           | 1FF0FF212 | t\n"
" Disjoint     | FF*FF**** | non-intersecting | FF1FF0212 | t\n"
" Disjoint     | FF*FF**** | overlapping      | 1010F0212 | f\n"
" Disjoint     | FF*FF**** | inside           | 1FF0FF212 | f"
msgstr ""
"SELECT pat.name AS relationship, pat.val AS pattern,\n"
"       mat.name AS position, mat.val AS matrix,\n"
"       ST_RelateMatch(mat.val, pat.val) AS match\n"
"    FROM (VALUES ( 'Equality', 'T1FF1FFF1' ),\n"
"                 ( 'Overlaps', 'T*T***T**' ),\n"
"                 ( 'Within',   'T*F**F***' ),\n"
"                 ( 'Disjoint', 'FF*FF****' )) AS pat(name,val)\n"
"    CROSS JOIN\n"
"        (VALUES  ('non-intersecting', 'FF1FF0212'),\n"
"                 ('overlapping',      '1010F0212'),\n"
"                 ('inside',           '1FF0FF212')) AS mat(name,val);\n"
"\n"
" relationship |  pattern  |     position     |  matrix   | match\n"
"--------------+-----------+------------------+-----------+-------\n"
" Equality     | T1FF1FFF1 | non-intersecting | FF1FF0212 | f\n"
" Equality     | T1FF1FFF1 | overlapping      | 1010F0212 | f\n"
" Equality     | T1FF1FFF1 | inside           | 1FF0FF212 | f\n"
" Overlaps     | T*T***T** | non-intersecting | FF1FF0212 | f\n"
" Overlaps     | T*T***T** | overlapping      | 1010F0212 | t\n"
" Overlaps     | T*T***T** | inside           | 1FF0FF212 | f\n"
" Within       | T*F**F*** | non-intersecting | FF1FF0212 | f\n"
" Within       | T*F**F*** | overlapping      | 1010F0212 | f\n"
" Within       | T*F**F*** | inside           | 1FF0FF212 | t\n"
" Disjoint     | FF*FF**** | non-intersecting | FF1FF0212 | t\n"
" Disjoint     | FF*FF**** | overlapping      | 1010F0212 | f\n"
" Disjoint     | FF*FF**** | inside           | 1FF0FF212 | f"

#. Tag: para
#: reference_relationship.xml:1371
#, no-c-format
msgid ", <xref linkend=\"ST_Relate\"/>"
msgstr ", <xref linkend=\"ST_Relate\"/>"

#. Tag: refname
#: reference_relationship.xml:1377
#, no-c-format
msgid "ST_Touches"
msgstr "ST_Touches"

#. Tag: refpurpose
#: reference_relationship.xml:1379
#, no-c-format
msgid ""
"Tests if two geometries have at least one point in common, but their "
"interiors do not intersect"
msgstr ""
"Teste si deux géométries ont au moins un point en commun, mais que leurs "
"intérieurs ne se croisent pas"

#. Tag: funcprototype
#: reference_relationship.xml:1385
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_Touches</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_Touches</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"

#. Tag: para
#: reference_relationship.xml:1400
#, no-c-format
msgid ""
"Returns <varname>TRUE</varname> if A and B intersect, but their interiors do "
"not intersect. Equivalently, A and B have at least one point in common, and "
"the common points lie in at least one boundary. For Point/Point inputs the "
"relationship is always <varname>FALSE</varname>, since points do not have a "
"boundary."
msgstr ""
"Retourne <varname>TRUE</varname> si A et B se croisent, mais que leurs "
"intérieurs ne se croisent pas. De manière équivalente, A et B ont au moins "
"un point en commun, et les points communs se situent dans au moins une "
"frontière. Pour les entrées point/point, la relation est toujours "
"<varname>FALSE</varname>, puisque les points n'ont pas de frontière."

#. Tag: para
#: reference_relationship.xml:1406
#, no-c-format
msgid ""
"In mathematical terms: <emphasis>ST_Touches(A, B) ⇔ (Int(A) ⋂ Int(B) ≠ ∅) ∧ "
"(A ⋂ B ≠ ∅) </emphasis>"
msgstr ""

#. Tag: para
#: reference_relationship.xml:1409
#, no-c-format
msgid ""
"This relationship holds if the DE-9IM Intersection Matrix for the two "
"geometries matches one of:"
msgstr ""
"Cette relation est valable si la matrice d'intersection DE-9IM pour les deux "
"géométries correspond à l'une d'entre elles :"

#. Tag: markup
#: reference_relationship.xml:1413
#, no-c-format
msgid "FT*******"
msgstr "FT*******"

#. Tag: markup
#: reference_relationship.xml:1417
#, no-c-format
msgid "F**T*****"
msgstr "F**T*****"

#. Tag: markup
#: reference_relationship.xml:1421
#, no-c-format
msgid "F***T****"
msgstr "F***T****"

#. Tag: para
#: reference_relationship.xml:1425
#, no-c-format
msgid ""
"&index_aware; To avoid using an index, use <function>_ST_Touches</function> "
"instead."
msgstr ""
"&index_aware; Pour éviter d'utiliser un index, utilisez plutôt la "
"<function>_ST_Touches</function>."

#. Tag: para
#: reference_relationship.xml:1434
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 5.1.28"
msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.28"

#. Tag: para
#: reference_relationship.xml:1440
#, no-c-format
msgid ""
"The <function>ST_Touches</function> predicate returns <varname>TRUE</"
"varname> in the following examples."
msgstr ""
"Le prédicat <function>ST_Touches</function> renvoie <varname>TRUE</varname> "
"dans les exemples suivants."

#. Tag: programlisting
#: reference_relationship.xml:1510
#, no-c-format
msgid ""
"SELECT ST_Touches('LINESTRING(0 0, 1 1, 0 2)'::geometry, 'POINT(1 1)'::"
"geometry);\n"
" st_touches\n"
"------------\n"
" f\n"
"(1 row)\n"
"\n"
"SELECT ST_Touches('LINESTRING(0 0, 1 1, 0 2)'::geometry, 'POINT(0 2)'::"
"geometry);\n"
" st_touches\n"
"------------\n"
" t\n"
"(1 row)"
msgstr ""
"SELECT ST_Touches('LINESTRING(0 0, 1 1, 0 2)'::geometry, 'POINT(1 1)'::"
"geometry);\n"
" st_touches\n"
"------------\n"
" f\n"
"(1 row)\n"
"\n"
"SELECT ST_Touches('LINESTRING(0 0, 1 1, 0 2)'::geometry, 'POINT(0 2)'::"
"geometry);\n"
" st_touches\n"
"------------\n"
" t\n"
"(1 row)"

#. Tag: refname
#: reference_relationship.xml:1516
#, no-c-format
msgid "ST_Within"
msgstr "ST_Within"

#. Tag: refpurpose
#: reference_relationship.xml:1518
#, no-c-format
msgid ""
"Tests if every point of A lies in B, and their interiors have a point in "
"common"
msgstr ""
"Tests si chaque point de A se trouve dans B, et que leurs intérieurs ont un "
"point commun"

#. Tag: funcprototype
#: reference_relationship.xml:1523
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_Within</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_Within</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"

#. Tag: para
#: reference_relationship.xml:1538
#, no-c-format
msgid ""
"Returns TRUE if geometry A is within geometry B. A is within B if and only "
"if all points of A lie inside (i.e. in the interior or boundary of) B (or "
"equivalently, no points of A lie in the exterior of B), and the interiors of "
"A and B have at least one point in common."
msgstr ""
"Renvoie TRUE si la géométrie A est à l'intérieur de la géométrie B. A est à "
"l'intérieur de B si et seulement si tous les points de A se trouvent à "
"l'intérieur (c'est-à-dire à l'intérieur ou à la limite) de B (ou de manière "
"équivalente, aucun point de A ne se trouve à l'extérieur de B), et si les "
"intérieurs de A et de B ont au moins un point en commun."

#. Tag: para
#: reference_relationship.xml:1543
#, no-c-format
msgid ""
"For this function to make sense, the source geometries must both be of the "
"same coordinate projection, having the same SRID."
msgstr ""
"Pour que cette fonction ait un sens, les géométries sources doivent toutes "
"deux avoir la même projection de coordonnées et le même SRID."

#. Tag: para
#: reference_relationship.xml:1548
#, no-c-format
msgid ""
"In mathematical terms: <emphasis>ST_Within(A, B) ⇔ (A ⋂ B = A) ∧ (Int(A) ⋂ "
"Int(B) ≠ ∅) </emphasis>"
msgstr ""

#. Tag: para
#: reference_relationship.xml:1551
#, no-c-format
msgid ""
"The within relation is reflexive: every geometry is within itself. The "
"relation is antisymmetric: if <code>ST_Within(A,B) = true</code> and "
"<code>ST_Within(B,A) = true</code>, then the two geometries must be "
"topologically equal (<code>ST_Equals(A,B) = true</code>)."
msgstr ""

#. Tag: para
#: reference_relationship.xml:1555
#, no-c-format
msgid ""
"ST_Within is the converse of <xref linkend=\"ST_Contains\"/>. So, "
"<code>ST_Within(A,B) = ST_Contains(B,A)</code>."
msgstr ""
"ST_Within est le contraire de <xref linkend=\"ST_Contains\"/>. Ainsi, "
"<code>ST_Within(A,B) = ST_Contains(B,A)</code>."

#. Tag: para
#: reference_relationship.xml:1558
#, no-c-format
msgid ""
"Because the interiors must have a common point, a subtlety of the definition "
"is that lines and points lying fully in the boundary of polygons or lines "
"are <emphasis>not</emphasis> within the geometry. For further details see "
"<ulink url=\"http://lin-ear-th-inking.blogspot.com/2007/06/subtleties-of-ogc-"
"covers-spatial.html\">Subtleties of OGC Covers, Contains, Within</ulink>. "
"The <xref linkend=\"ST_CoveredBy\"/> predicate provides a more inclusive "
"relationship."
msgstr ""
"Comme les intérieurs doivent avoir un point commun, une subtilité de la "
"définition est que les lignes et les points situés entièrement dans la "
"limite des polygones ou des lignes ne sont <emphasis>pas</emphasis> à "
"l'intérieur de la géométrie. Pour plus de détails, voir <ulink url=\"http://"
"lin-ear-th-inking.blogspot.com/2007/06/subtleties-of-ogc-covers-spatial."
"html\">Subtleties of OGC Covers, Contains, Within</ulink>. Le prédicat <xref "
"linkend=\"ST_CoveredBy\"/> fournit une relation plus inclusive."

#. Tag: para
#: reference_relationship.xml:1564
#, no-c-format
msgid ""
"&index_aware; To avoid index use, use the function <function>_ST_Within</"
"function>."
msgstr ""
"&index_aware; Pour éviter l'utilisation d'un index, utilisez la fonction "
"<function>_ST_Within</function>."

#. Tag: para
#: reference_relationship.xml:1582
#, no-c-format
msgid "&sfs_compliant; s2.1.1.2 // s2.1.13.3 - a.Relate(b, 'T*F**F***')"
msgstr "&sfs_compliant; s2.1.1.2 // s2.1.13.3 - a.Relate(b, 'T*F**F***')"

#. Tag: para
#: reference_relationship.xml:1585
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 5.1.30"
msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.30"

#. Tag: programlisting
#: reference_relationship.xml:1590
#, no-c-format
msgid ""
"--a circle within a circle\n"
"SELECT ST_Within(smallc,smallc) As smallinsmall,\n"
"  ST_Within(smallc, bigc) As smallinbig,\n"
"  ST_Within(bigc,smallc) As biginsmall,\n"
"  ST_Within(ST_Union(smallc, bigc), bigc) as unioninbig,\n"
"  ST_Within(bigc, ST_Union(smallc, bigc)) as biginunion,\n"
"  ST_Equals(bigc, ST_Union(smallc, bigc)) as bigisunion\n"
"FROM\n"
"(\n"
"SELECT ST_Buffer(ST_GeomFromText('POINT(50 50)'), 20) As smallc,\n"
"  ST_Buffer(ST_GeomFromText('POINT(50 50)'), 40) As bigc) As foo;\n"
"--Result\n"
" smallinsmall | smallinbig | biginsmall | unioninbig | biginunion | "
"bigisunion\n"
"--------------+------------+------------+------------+------------"
"+------------\n"
" t            | t          | f          | t          | t          | t\n"
"(1 row)"
msgstr ""
"-- un cercle à l'intérieur d'un cercle\n"
"SELECT ST_Within(smallc,smallc) As smallinsmall,\n"
"  ST_Within(smallc, bigc) As smallinbig,\n"
"  ST_Within(bigc,smallc) As biginsmall,\n"
"  ST_Within(ST_Union(smallc, bigc), bigc) as unioninbig,\n"
"  ST_Within(bigc, ST_Union(smallc, bigc)) as biginunion,\n"
"  ST_Equals(bigc, ST_Union(smallc, bigc)) as bigisunion\n"
"FROM\n"
"(\n"
"SELECT ST_Buffer(ST_GeomFromText('POINT(50 50)'), 20) As smallc,\n"
"  ST_Buffer(ST_GeomFromText('POINT(50 50)'), 40) As bigc) As foo;\n"
"--Result\n"
" smallinsmall | smallinbig | biginsmall | unioninbig | biginunion | "
"bigisunion\n"
"--------------+------------+------------+------------+------------"
"+------------\n"
" t            | t          | f          | t          | t          | t\n"
"(1 row)"

#. Tag: para
#: reference_relationship.xml:1601
#, no-c-format
msgid ""
", <xref linkend=\"ST_CoveredBy\"/>, <xref linkend=\"ST_Equals\"/>, <xref "
"linkend=\"ST_IsValid\"/>"
msgstr ""
", <xref linkend=\"ST_CoveredBy\"/>, <xref linkend=\"ST_Equals\"/>, <xref "
"linkend=\"ST_IsValid\"/>"

#. Tag: title
#: reference_relationship.xml:1609
#, no-c-format
msgid "Distance Relationships"
msgstr "Relations de distance"

#. Tag: refname
#: reference_relationship.xml:1613
#, no-c-format
msgid "ST_3DDWithin"
msgstr "ST_3DDWithin"

#. Tag: refpurpose
#: reference_relationship.xml:1615
#, no-c-format
msgid "Tests if two 3D geometries are within a given 3D distance"
msgstr "Teste si deux géométries 3D se trouvent à une distance 3D donnée"

#. Tag: funcprototype
#: reference_relationship.xml:1619
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_3DDWithin</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
"<paramdef><type>double precision </type> <parameter>distance_of_srid</"
"parameter></paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_3DDWithin</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
"<paramdef><type>double precision </type> <parameter>distance_of_srid</"
"parameter></paramdef>"

#. Tag: para
#: reference_relationship.xml:1637
#, no-c-format
msgid ""
"Returns true if the 3D distance between two geometry values is no larger "
"than distance <varname>distance_of_srid</varname>. The distance is specified "
"in units defined by the spatial reference system of the geometries. For this "
"function to make sense the source geometries must be in the same coordinate "
"system (have the same SRID)."
msgstr ""
"Renvoie true si la distance 3D entre deux valeurs géométriques n'est pas "
"supérieure à la distance <varname>distance_of_srid</varname>. La distance "
"est spécifiée en unités définies par le système de référence spatial des "
"géométries. Pour que cette fonction ait un sens, les géométries sources "
"doivent se trouver dans le même système de coordonnées (avoir le même SRID)."

#. Tag: para
#: reference_relationship.xml:1649
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM ?"
msgstr "&sqlmm_compliant; SQL-MM ?"

#. Tag: programlisting
#: reference_relationship.xml:1657
#, no-c-format
msgid ""
"-- Geometry example - units in meters (SRID: 2163 US National Atlas Equal "
"area) (3D point and line compared 2D point and line)\n"
"-- Note: currently no vertical datum support so Z is not transformed and "
"assumed to be same units as final.\n"
"SELECT ST_3DDWithin(\n"
"      ST_Transform(ST_GeomFromEWKT('SRID=4326;POINT(-72.1235 42.3521 "
"4)'),2163),\n"
"      ST_Transform(ST_GeomFromEWKT('SRID=4326;LINESTRING(-72.1260 42.45 15, "
"-72.123 42.1546 20)'),2163),\n"
"      126.8\n"
"    ) As within_dist_3d,\n"
"ST_DWithin(\n"
"      ST_Transform(ST_GeomFromEWKT('SRID=4326;POINT(-72.1235 42.3521 "
"4)'),2163),\n"
"      ST_Transform(ST_GeomFromEWKT('SRID=4326;LINESTRING(-72.1260 42.45 15, "
"-72.123 42.1546 20)'),2163),\n"
"      126.8\n"
"    ) As within_dist_2d;\n"
"\n"
" within_dist_3d | within_dist_2d\n"
"----------------+----------------\n"
" f              | t"
msgstr ""
"-- Exemple de géométrie - unités en mètres (SRID : 2163 US National Atlas "
"Equal area) (point et ligne 3D comparés à un point et une ligne 2D)\n"
"-- Note : actuellement, il n'y a pas de support pour le datum vertical, donc "
"Z n'est pas transformé et est supposé avoir les mêmes unités que le final.\n"
"SELECT ST_3DDWithin(\n"
"      ST_Transform(ST_GeomFromEWKT('SRID=4326;POINT(-72.1235 42.3521 "
"4)'),2163),\n"
"      ST_Transform(ST_GeomFromEWKT('SRID=4326;LINESTRING(-72.1260 42.45 15, "
"-72.123 42.1546 20)'),2163),\n"
"      126.8\n"
"    ) As within_dist_3d,\n"
"ST_DWithin(\n"
"      ST_Transform(ST_GeomFromEWKT('SRID=4326;POINT(-72.1235 42.3521 "
"4)'),2163),\n"
"      ST_Transform(ST_GeomFromEWKT('SRID=4326;LINESTRING(-72.1260 42.45 15, "
"-72.123 42.1546 20)'),2163),\n"
"      126.8\n"
"    ) As within_dist_2d;\n"
"\n"
" within_dist_3d | within_dist_2d\n"
"----------------+----------------\n"
" f              | t"

#. Tag: para
#: reference_relationship.xml:1663
#, no-c-format
msgid ""
", <xref linkend=\"ST_DWithin\"/>, <xref linkend=\"ST_DFullyWithin\"/>, <xref "
"linkend=\"ST_3DDistance\"/>, <xref linkend=\"ST_Distance\"/>, <xref "
"linkend=\"ST_3DMaxDistance\"/>, <xref linkend=\"ST_Transform\"/>"
msgstr ""
", <xref linkend=\"ST_DWithin\"/>, <xref linkend=\"ST_DFullyWithin\"/>, <xref "
"linkend=\"ST_3DDistance\"/>, <xref linkend=\"ST_Distance\"/>, <xref "
"linkend=\"ST_3DMaxDistance\"/>, <xref linkend=\"ST_Transform\"/>"

#. Tag: refname
#: reference_relationship.xml:1673
#, no-c-format
msgid "ST_3DDFullyWithin"
msgstr "ST_3DDFullyWithin"

#. Tag: refpurpose
#: reference_relationship.xml:1675
#, no-c-format
msgid "Tests if two 3D geometries are entirely within a given 3D distance"
msgstr ""
"Teste si deux géométries 3D sont entièrement comprises dans une distance 3D "
"donnée"

#. Tag: funcprototype
#: reference_relationship.xml:1680
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_3DDFullyWithin</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
"<paramdef><type>double precision </type> <parameter>distance</parameter></"
"paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_3DDFullyWithin</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
"<paramdef><type>double precision </type> <parameter>distance</parameter></"
"paramdef>"

#. Tag: para
#: reference_relationship.xml:1698
#, no-c-format
msgid ""
"Returns true if the 3D geometries are fully within the specified distance of "
"one another. The distance is specified in units defined by the spatial "
"reference system of the geometries. For this function to make sense, the "
"source geometries must both be of the same coordinate projection, having the "
"same SRID."
msgstr ""
"Renvoie true si les géométries 3D se trouvent à la distance spécifiée l'une "
"de l'autre. La distance est spécifiée en unités définies par le système de "
"référence spatiale des géométries. Pour que cette fonction ait un sens, les "
"géométries sources doivent toutes deux avoir la même projection de "
"coordonnées et le même SRID."

#. Tag: programlisting
#: reference_relationship.xml:1715
#, no-c-format
msgid ""
"-- This compares the difference between fully within and distance within as "
"well\n"
"    -- as the distance fully within for the 2D footprint of the line/point "
"vs. the 3d fully within\n"
"    SELECT ST_3DDFullyWithin(geom_a, geom_b, 10) as D3DFullyWithin10, "
"ST_3DDWithin(geom_a, geom_b, 10) as D3DWithin10,\n"
"  ST_DFullyWithin(geom_a, geom_b, 20) as D2DFullyWithin20,\n"
"  ST_3DDFullyWithin(geom_a, geom_b, 20) as D3DFullyWithin20 from\n"
"    (select ST_GeomFromEWKT('POINT(1 1 2)') as geom_a,\n"
"    ST_GeomFromEWKT('LINESTRING(1 5 2, 2 7 20, 1 9 100, 14 12 3)') as "
"geom_b) t1;\n"
" d3dfullywithin10 | d3dwithin10 | d2dfullywithin20 | d3dfullywithin20\n"
"------------------+-------------+------------------+------------------\n"
" f                | t           | t                | f"
msgstr ""
"-- Cela permet de comparer la différence entre l'intérieur et la distance à "
"l'intérieur.\n"
"-- comme la distance à l'intérieur de l'empreinte 2D de la ligne/du point "
"par rapport à la distance à l'intérieur de l'empreinte 3D.\n"
"    SELECT ST_3DDFullyWithin(geom_a, geom_b, 10) as D3DFullyWithin10, "
"ST_3DDWithin(geom_a, geom_b, 10) as D3DWithin10,\n"
"  ST_DFullyWithin(geom_a, geom_b, 20) as D2DFullyWithin20,\n"
"  ST_3DDFullyWithin(geom_a, geom_b, 20) as D3DFullyWithin20 from\n"
"    (select ST_GeomFromEWKT('POINT(1 1 2)') as geom_a,\n"
"    ST_GeomFromEWKT('LINESTRING(1 5 2, 2 7 20, 1 9 100, 14 12 3)') as "
"geom_b) t1;\n"
" d3dfullywithin10 | d3dwithin10 | d2dfullywithin20 | d3dfullywithin20\n"
"------------------+-------------+------------------+------------------\n"
" f                | t           | t                | f"

#. Tag: para
#: reference_relationship.xml:1721
#, no-c-format
msgid ""
", <xref linkend=\"ST_DWithin\"/>, <xref linkend=\"ST_DFullyWithin\"/>, <xref "
"linkend=\"ST_3DMaxDistance\"/>"
msgstr ""
", <xref linkend=\"ST_DWithin\"/>, <xref linkend=\"ST_DFullyWithin\"/>, <xref "
"linkend=\"ST_3DMaxDistance\"/>"

#. Tag: refname
#: reference_relationship.xml:1729
#, no-c-format
msgid "ST_DFullyWithin"
msgstr "ST_DFullyWithin"

#. Tag: refpurpose
#: reference_relationship.xml:1731
#, no-c-format
msgid "Tests if two geometries are entirely within a given distance"
msgstr ""
"Teste si deux géométries sont entièrement comprises dans une distance donnée"

#. Tag: funcprototype
#: reference_relationship.xml:1736
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_DFullyWithin</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
"<paramdef><type>double precision </type> <parameter>distance</parameter></"
"paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_DFullyWithin</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
"<paramdef><type>double precision </type> <parameter>distance</parameter></"
"paramdef>"

#. Tag: para
#: reference_relationship.xml:1754
#, no-c-format
msgid ""
"Returns true if the geometries are entirely within the specified distance of "
"one another. The distance is specified in units defined by the spatial "
"reference system of the geometries. For this function to make sense, the "
"source geometries must both be of the same coordinate projection, having the "
"same SRID."
msgstr ""
"Renvoie un résultat positif si les géométries sont entièrement situées à la "
"distance spécifiée l'une de l'autre. La distance est spécifiée en unités "
"définies par le système de référence spatiale des géométries. Pour que cette "
"fonction ait un sens, les géométries sources doivent toutes deux avoir la "
"même projection de coordonnées et le même SRID."

#. Tag: para
#: reference_relationship.xml:1762
#, no-c-format
msgid "Availability: 1.5.0"
msgstr "Disponibilité : 1.5.0"

#. Tag: programlisting
#: reference_relationship.xml:1767
#, no-c-format
msgid ""
"postgis=# SELECT ST_DFullyWithin(geom_a, geom_b, 10) as DFullyWithin10, "
"ST_DWithin(geom_a, geom_b, 10) as DWithin10, ST_DFullyWithin(geom_a, geom_b, "
"20) as DFullyWithin20 from\n"
"    (select ST_GeomFromText('POINT(1 1)') as geom_a,"
"ST_GeomFromText('LINESTRING(1 5, 2 7, 1 9, 14 12)') as geom_b) t1;\n"
"\n"
"-----------------\n"
" DFullyWithin10 | DWithin10 | DFullyWithin20 |\n"
"---------------+----------+---------------+\n"
" f             | t        | t             |"
msgstr ""
"postgis=# SELECT ST_DFullyWithin(geom_a, geom_b, 10) as DFullyWithin10, "
"ST_DWithin(geom_a, geom_b, 10) as DWithin10, ST_DFullyWithin(geom_a, geom_b, "
"20) as DFullyWithin20 from\n"
"    (select ST_GeomFromText('POINT(1 1)') as geom_a,"
"ST_GeomFromText('LINESTRING(1 5, 2 7, 1 9, 14 12)') as geom_b) t1;\n"
"\n"
"-----------------\n"
" DFullyWithin10 | DWithin10 | DFullyWithin20 |\n"
"---------------+----------+---------------+\n"
" f             | t        | t             |"

#. Tag: para
#: reference_relationship.xml:1773
#, no-c-format
msgid ""
", <xref linkend=\"ST_DWithin\"/>, <xref linkend=\"ST_3DDWithin\"/>, <xref "
"linkend=\"ST_3DDFullyWithin\"/>"
msgstr ""
", <xref linkend=\"ST_DWithin\"/>, <xref linkend=\"ST_3DDWithin\"/>, <xref "
"linkend=\"ST_3DDFullyWithin\"/>"

#. Tag: refname
#: reference_relationship.xml:1780
#, no-c-format
msgid "ST_DWithin"
msgstr "ST_DWithin"

#. Tag: refpurpose
#: reference_relationship.xml:1782
#, no-c-format
msgid "Tests if two geometries are within a given distance"
msgstr "Teste si deux géométries se trouvent à une distance donnée"

#. Tag: funcsynopsis
#: reference_relationship.xml:1786
#, no-c-format
msgid ""
"<funcprototype> <funcdef>boolean <function>ST_DWithin</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
"<paramdef><type>double precision </type> <parameter>distance_of_srid</"
"parameter></paramdef> </funcprototype> <funcprototype> <funcdef>boolean "
"<function>ST_DWithin</function></funcdef> <paramdef><type>geography </type> "
"<parameter>gg1</parameter></paramdef> <paramdef><type>geography </type> "
"<parameter>gg2</parameter></paramdef> <paramdef><type>double precision </"
"type> <parameter>distance_meters</parameter></paramdef> <paramdef "
"choice=\"opt\"><type>boolean </type> <parameter>use_spheroid = true</"
"parameter></paramdef> </funcprototype>"
msgstr ""
"<funcprototype> <funcdef>boolean <function>ST_DWithin</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
"<paramdef><type>double precision </type> <parameter>distance_of_srid</"
"parameter></paramdef> </funcprototype> <funcprototype> <funcdef>boolean "
"<function>ST_DWithin</function></funcdef> <paramdef><type>geography </type> "
"<parameter>gg1</parameter></paramdef> <paramdef><type>geography </type> "
"<parameter>gg2</parameter></paramdef> <paramdef><type>double precision </"
"type> <parameter>distance_meters</parameter></paramdef> <paramdef "
"choice=\"opt\"><type>boolean </type> <parameter>use_spheroid = true</"
"parameter></paramdef> </funcprototype>"

#. Tag: para
#: reference_relationship.xml:1819
#, no-c-format
msgid "Returns true if the geometries are within a given distance"
msgstr "Renvoie true si les géométries se trouvent à une distance donnée"

#. Tag: para
#: reference_relationship.xml:1821
#, no-c-format
msgid ""
"For <type>geometry</type>: The distance is specified in units defined by the "
"spatial reference system of the geometries. For this function to make sense, "
"the source geometries must be in the same coordinate system (have the same "
"SRID)."
msgstr ""
"Pour le type <type>geometry</type> : la distance est spécifiée en unités "
"définies par le système de référence spatiale des géométries. Pour que cette "
"fonction ait un sens, les géométries sources doivent se trouver dans le même "
"système de coordonnées (avoir le même SRID)."

#. Tag: para
#: reference_relationship.xml:1826
#, no-c-format
msgid ""
"For <type>geography</type>: units are in meters and distance measurement "
"defaults to <varname>use_spheroid = true</varname>. For faster evaluation "
"use <varname>use_spheroid = false</varname> to measure on the sphere."
msgstr ""
"Pour le type <type>geography</type> : les unités sont en mètres et la mesure "
"de la distance est par défaut <varname>use_spheroid = true</varname>. Pour "
"une évaluation plus rapide, utilisez <varname>use_spheroid = false</varname> "
"pour mesurer sur la sphère."

#. Tag: para
#: reference_relationship.xml:1831
#, no-c-format
msgid "Use <xref linkend=\"ST_3DDWithin\"/> for 3D geometries."
msgstr "Utilisez <xref linkend=\"ST_3DDWithin\"/> pour les géométries 3D."

#. Tag: para
#: reference_relationship.xml:1834
#, no-c-format
msgid ""
"This function call includes a bounding box comparison that makes use of any "
"indexes that are available on the geometries."
msgstr ""
"Cet appel de fonction inclut une comparaison de la boîte de délimitation qui "
"utilise tous les index disponibles sur les géométries."

#. Tag: para
#: reference_relationship.xml:1839
#, no-c-format
msgid "&sfs_compliant;"
msgstr "&sfs_compliant;"

#. Tag: para
#: reference_relationship.xml:1840
#, no-c-format
msgid "Availability: 1.5.0 support for geography was introduced"
msgstr ""
"Disponibilité : la prise en charge du type geography a été introduite dans "
"la version 1.5.0"

#. Tag: para
#: reference_relationship.xml:1841
#, no-c-format
msgid ""
"Enhanced: 2.1.0 improved speed for geography. See <ulink url=\"http://blog."
"opengeo.org/2012/07/12/making-geography-faster/\">Making Geography faster</"
"ulink> for details."
msgstr ""
"Amélioration : la version 2.1.0 a amélioré la vitesse de la géographie. Voir "
"<ulink url=\"http://blog.opengeo.org/2012/07/12/making-geography-faster/"
"\">Making Geography faster</ulink> pour plus de détails."

#. Tag: para
#: reference_relationship.xml:1842
#, no-c-format
msgid "Enhanced: 2.1.0 support for curved geometries was introduced."
msgstr ""
"Amélioration : la prise en charge des géométries courbes a été introduite "
"dans la version 2.1.0."

#. Tag: para
#: reference_relationship.xml:1844
#, no-c-format
msgid ""
"Prior to 1.3, <xref linkend=\"ST_Expand\"/> was commonly used in conjunction "
"with &amp;&amp; and ST_Distance to test for distance, and in pre-1.3.4 this "
"function used that logic. From 1.3.4, ST_DWithin uses a faster short-circuit "
"distance function."
msgstr ""
"Avant la version 1.3, <xref linkend=\"ST_Expand\"/> était couramment utilisé "
"en conjonction avec &amp;&amp; et ST_Distance pour tester la distance, et "
"avant la version 1.3.4, cette fonction utilisait cette logique. À partir de "
"la version 1.3.4, ST_DWithin utilise une fonction de distance de court-"
"circuit plus rapide."

#. Tag: programlisting
#: reference_relationship.xml:1852
#, no-c-format
msgid ""
"-- Find the nearest hospital to each school\n"
"-- that is within 3000 units of the school.\n"
"--  We do an ST_DWithin search to utilize indexes to limit our search list\n"
"--  that the non-indexable ST_Distance needs to process\n"
"-- If the units of the spatial reference is meters then units would be "
"meters\n"
"SELECT DISTINCT ON (s.gid) s.gid, s.school_name, s.geom, h.hospital_name\n"
"  FROM schools s\n"
"    LEFT JOIN hospitals h ON ST_DWithin(s.geom, h.geom, 3000)\n"
"  ORDER BY s.gid, ST_Distance(s.geom, h.geom);\n"
"\n"
"-- The schools with no close hospitals\n"
"-- Find all schools with no hospital within 3000 units\n"
"-- away from the school.  Units is in units of spatial ref (e.g. meters, "
"feet, degrees)\n"
"SELECT s.gid, s.school_name\n"
"  FROM schools s\n"
"    LEFT JOIN hospitals h ON ST_DWithin(s.geom, h.geom, 3000)\n"
"  WHERE h.gid IS NULL;\n"
"\n"
"-- Find broadcasting towers that receiver with limited range can receive.\n"
"-- Data is geometry in Spherical Mercator (SRID=3857), ranges are "
"approximate.\n"
"\n"
"-- Create geometry index that will check proximity limit of user to tower\n"
"CREATE INDEX ON broadcasting_towers using gist (geom);\n"
"\n"
"-- Create geometry index that will check proximity limit of tower to user\n"
"CREATE INDEX ON broadcasting_towers using gist (ST_Expand(geom, "
"sending_range));\n"
"\n"
"-- Query towers that 4-kilometer receiver in Minsk Hackerspace can get\n"
"-- Note: two conditions, because shorter LEAST(b.sending_range, 4000) will "
"not use index.\n"
"SELECT b.tower_id, b.geom\n"
"  FROM broadcasting_towers b\n"
"  WHERE ST_DWithin(b.geom, 'SRID=3857;POINT(3072163.4 7159374.1)', 4000)\n"
"    AND ST_DWithin(b.geom, 'SRID=3857;POINT(3072163.4 7159374.1)', b."
"sending_range);"
msgstr ""
"-- Trouvez l'hôpital le plus proche de chaque école\n"
"-- Nous effectuons une recherche ST_DWithin afin d'utiliser des index pour "
"limiter notre liste de recherche.\n"
"-- Nous effectuons une recherche ST_DWithin pour utiliser les index afin de "
"limiter notre liste de recherche.\n"
"-- Nous faisons une recherche ST_DWithin pour utiliser des index afin de "
"limiter notre liste de recherche.\n"
"-- Si l'unité de la référence spatiale est le mètre, l'unité sera le mètre.\n"
"SELECT DISTINCT ON (s.gid) s.gid, s.school_name, s.geom, h.hospital_name\n"
"  FROM schools s\n"
"    LEFT JOIN hospitals h ON ST_DWithin(s.geom, h.geom, 3000)\n"
"  ORDER BY s.gid, ST_Distance(s.geom, h.geom);\n"
"\n"
"-- Les écoles qui n'ont pas d'hôpital à proximité\n"
"-- Trouver toutes les écoles qui n'ont pas d'hôpital à moins de 3000 unités\n"
"-- de l'école.  Les unités sont des unités de référence spatiale (par "
"exemple, mètres, pieds, degrés).\n"
"SELECT s.gid, s.school_name\n"
"  FROM schools s\n"
"    LEFT JOIN hospitals h ON ST_DWithin(s.geom, h.geom, 3000)\n"
"  WHERE h.gid IS NULL;\n"
"\n"
"-- Trouver les tours de radiodiffusion que les récepteurs à portée limitée "
"peuvent recevoir.\n"
"-- Les données sont des géométries en Mercator sphérique (SRID=3857), les "
"portées sont approximatives.\n"
"\n"
"-- Créer un index géométrique qui vérifiera la limite de proximité de "
"l'utilisateur par rapport à la tour.\n"
"CREATE INDEX ON broadcasting_towers using gist (geom);\n"
"\n"
"-- Créer un index géométrique qui vérifiera la limite de proximité de la "
"tour par rapport à l'utilisateur\n"
"CREATE INDEX ON broadcasting_towers using gist (ST_Expand(geom, "
"sending_range));\n"
"\n"
"-- Interroger les tours que le récepteur de 4 kilomètres dans le Hackerspace "
"de Minsk peut obtenir.\n"
"-- Note : deux conditions, parce que le plus court LEAST(b.sending_range, "
"4000) n'utilisera pas l'index.\n"
"SELECT b.tower_id, b.geom\n"
"  FROM broadcasting_towers b\n"
"  WHERE ST_DWithin(b.geom, 'SRID=3857;POINT(3072163.4 7159374.1)', 4000)\n"
"    AND ST_DWithin(b.geom, 'SRID=3857;POINT(3072163.4 7159374.1)', b."
"sending_range);"

#. Tag: para
#: reference_relationship.xml:1858
#, no-c-format
msgid ", <xref linkend=\"ST_3DDWithin\"/>"
msgstr ", <xref linkend=\"ST_3DDWithin\"/>"

#. Tag: refname
#: reference_relationship.xml:1864
#, no-c-format
msgid "ST_PointInsideCircle"
msgstr "ST_PointInsideCircle"

#. Tag: refpurpose
#: reference_relationship.xml:1866
#, no-c-format
msgid ""
"Tests if a point geometry is inside a circle defined by a center and radius"
msgstr ""
"Teste si un point géométrique se trouve à l'intérieur d'un cercle défini par "
"un centre et un rayon"

#. Tag: funcprototype
#: reference_relationship.xml:1871
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_PointInsideCircle</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>a_point</parameter></paramdef> "
"<paramdef><type>float </type> <parameter>center_x</parameter></paramdef> "
"<paramdef><type>float </type> <parameter>center_y</parameter></paramdef> "
"<paramdef><type>float </type> <parameter>radius</parameter></paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_PointInsideCircle</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>a_point</parameter></paramdef> "
"<paramdef><type>float </type> <parameter>center_x</parameter></paramdef> "
"<paramdef><type>float </type> <parameter>center_y</parameter></paramdef> "
"<paramdef><type>float </type> <parameter>radius</parameter></paramdef>"

#. Tag: para
#: reference_relationship.xml:1884
#, no-c-format
msgid ""
"Returns true if the geometry is a point and is inside the circle with center "
"<varname>center_x</varname>,<varname>center_y</varname> and radius "
"<varname>radius</varname>."
msgstr ""
"Retourne true si la géométrie est un point et se trouve à l'intérieur du "
"cercle de centre <varname>center_x</varname>,<varname>center_y</varname> et "
"de rayon <varname>radius</varname>."

#. Tag: para
#: reference_relationship.xml:1888
#, no-c-format
msgid ""
"Does not use spatial indexes. Use <xref linkend=\"ST_DWithin\"/> instead."
msgstr ""
"N'utilise pas les index spatiaux. Utilisez plutôt <xref "
"linkend=\"ST_DWithin\"/>."

#. Tag: para
#: reference_relationship.xml:1890
#, no-c-format
msgid "Availability: 1.2"
msgstr "Disponibilité : 1.2"

#. Tag: para
#: reference_relationship.xml:1891
#, no-c-format
msgid "Changed: 2.2.0 In prior versions this was called ST_Point_Inside_Circle"
msgstr ""
"Modifié : 2.2.0 Dans les versions précédentes, cette fonction était appelée "
"ST_Point_Inside_Circle"

#. Tag: programlisting
#: reference_relationship.xml:1898
#, no-c-format
msgid ""
"SELECT ST_PointInsideCircle(ST_Point(1,2), 0.5, 2, 3);\n"
" st_pointinsidecircle\n"
"------------------------\n"
" t"
msgstr ""
"SELECT ST_PointInsideCircle(ST_Point(1,2), 0.5, 2, 3);\n"
" st_pointinsidecircle\n"
"------------------------\n"
" t"

#, no-c-format
#~ msgid ""
#~ "Returns <varname>true</varname> if every point of B lies inside A (or "
#~ "equivalently, no point of B lies in the the boundary or exterior of A)."
#~ msgstr ""
#~ "Retourne <varname>true</varname> si chaque point de B se trouve à "
#~ "l'intérieur de A (ou de façon équivalente, aucun point de B ne se trouve "
#~ "à la limite ou à l'extérieur de A)."

#, no-c-format
#~ msgid ""
#~ "Every point of the other geometry is a point of this geometry's interior. "
#~ "The DE-9IM Intersection Matrix for the two geometries matches [T**FF*FF*] "
#~ "used in <xref linkend=\"ST_Relate\"/>"
#~ msgstr ""
#~ "Chaque point de l'autre géométrie est un point de l'intérieur de cette "
#~ "géométrie. La matrice d'intersection DE-9IM pour les deux géométries "
#~ "correspond à [T**FF*FF*] utilisée dans <xref linkend=\"ST_Relate\"/>"

#, no-c-format
#~ msgid ""
#~ "Compares two geometry objects and returns <varname>true</varname> if "
#~ "their intersection \"spatially cross\", that is, the geometries have "
#~ "some, but not all interior points in common. The intersection of the "
#~ "interiors of the geometries must be non-empty and must have dimension "
#~ "less than the maximum dimension of the two input geometries. "
#~ "Additionally, the intersection of the two geometries must not equal "
#~ "either of the source geometries. Otherwise, it returns <varname>false</"
#~ "varname>."
#~ msgstr ""
#~ "Compare deux objets géométriques et renvoie <varname>true</varname> si "
#~ "leur intersection se \"croise spatialement\", c'est-à-dire que les "
#~ "géométries ont certains points intérieurs en commun, mais pas tous. "
#~ "L'intersection des intérieurs des géométries doit être non vide et doit "
#~ "avoir une dimension inférieure à la dimension maximale des deux "
#~ "géométries d'entrée. En outre, l'intersection des deux géométries ne doit "
#~ "pas être égale à l'une des géométries sources. Dans le cas contraire, la "
#~ "fonction renvoie <varname>false</varname>."

#, no-c-format
#~ msgid "In mathematical terms, this is:"
#~ msgstr "En termes mathématiques, c'est :"

#, no-c-format
#~ msgid ""
#~ "For Point/Point and Area/Area situations this predicate returns "
#~ "<varname>false</varname>."
#~ msgstr ""
#~ "Pour les situations point/point et zone/zone, ce prédicat renvoie "
#~ "<varname>false</varname>."

#, no-c-format
#~ msgid ""
#~ "Overlaps, Touches, Within all imply geometries are not spatially "
#~ "disjoint. If any of the aforementioned returns true, then the geometries "
#~ "are not spatially disjoint. Disjoint implies false for spatial "
#~ "intersection."
#~ msgstr ""
#~ "Overlaps, Touches, Within impliquent tous que les géométries ne sont pas "
#~ "disjointes dans l'espace. Si l'un des éléments susmentionnés renvoie la "
#~ "valeur \"true\", les géométries ne sont pas disjointes dans l'espace. La "
#~ "disjonction implique que l'intersection spatiale est fausse."

#, no-c-format
#~ msgid ""
#~ "Returns <varname>true</varname> if the given geometries are \"spatially "
#~ "equal\". Use this for a 'better' answer than '='. Note by spatially equal "
#~ "we mean ST_Within(A,B) = true and ST_Within(B,A) = true and also mean "
#~ "ordering of points can be different but represent the same geometry "
#~ "structure. To verify the order of points is consistent, use "
#~ "ST_OrderingEquals (it must be noted ST_OrderingEquals is a little more "
#~ "stringent than simply verifying order of points are the same)."
#~ msgstr ""
#~ "Renvoie <varname>true</varname> si les géométries données sont "
#~ "\"spatialement égales\". Utilisez cette fonction pour obtenir une "
#~ "\"meilleure\" réponse que \"=\". Notez que l'égalité spatiale signifie "
#~ "que ST_Within(A,B) = true et ST_Within(B,A) = true et que l'ordre des "
#~ "points peut être différent mais représenter la même structure "
#~ "géométrique. Pour vérifier que l'ordre des points est cohérent, utilisez "
#~ "ST_OrderingEquals (il faut noter que ST_OrderingEquals est un peu plus "
#~ "rigoureux que la simple vérification de l'ordre des points)."

#, no-c-format
#~ msgid ""
#~ "Compares two geometries and returns <varname>true</varname> if they "
#~ "intersect. Geometries intersect if they have any point in common."
#~ msgstr ""
#~ "Compare deux géométries et renvoie <varname>true</varname> si elles se "
#~ "croisent. Les géométries se croisent si elles ont un point commun."

#, no-c-format
#~ msgid ""
#~ "Returns TRUE if geometry A and B \"spatially overlap\". Two geometries "
#~ "overlap if they have the same dimension, their interiors intersect in "
#~ "that dimension. and each has at least one point inside the other (or "
#~ "equivalently, neither one covers the other). The overlaps relationship is "
#~ "symmetric and irreflexive."
#~ msgstr ""
#~ "Renvoie TRUE si les géométries A et B se \"chevauchent spatialement\". "
#~ "Deux géométries se chevauchent si elles ont la même dimension, si leurs "
#~ "intérieurs se croisent dans cette dimension et si chacune a au moins un "
#~ "point à l'intérieur de l'autre (ou, de manière équivalente, si aucune des "
#~ "deux ne recouvre l'autre). La relation de chevauchement est symétrique et "
#~ "irréflexive."

#, no-c-format
#~ msgid "In mathematical terms, this relationship is:"
#~ msgstr "En termes mathématiques, cette relation est :"

#, no-c-format
#~ msgid ""
#~ "The within relationship is reflexive: every geometry is within itself. "
#~ "The relationship is antisymmetric: if <code>ST_Within(A,B) = true</code> "
#~ "and <code>ST_Within(B,A) = true</code>, then the two geometries must be "
#~ "topologically equal (<code>ST_Equals(A,B) = true</code>)."
#~ msgstr ""
#~ "La relation within est réflexive : toute géométrie est à l'intérieur "
#~ "d'elle-même. La relation est antisymétrique : si <code>ST_Within(A,B) = "
#~ "true</code> et <code>ST_Within(B,A) = true</code>, alors les deux "
#~ "géométries doivent être topologiquement égales (<code>ST_Equals(A,B) = "
#~ "true</code>)."
