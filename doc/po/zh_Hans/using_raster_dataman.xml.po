# Chinese translations for build-pg package.
# Automatically generated, 2023.
#
# Zuochenwei <zuochenwei5@gmail.com>, 2023.
# Sandro Santilli <strk@kbt.io>, 2023.
msgid ""
msgstr ""
"Project-Id-Version: build-pg 13\n"
"Report-Msgid-Bugs-To: https://bugs.kde.org\n"
"POT-Creation-Date: 2023-09-12 22:08+0000\n"
"PO-Revision-Date: 2023-09-13 06:31+0000\n"
"Last-Translator: Zuochenwei <zuochenwei5@gmail.com>\n"
"Language-Team: Chinese (Simplified) <https://weblate.osgeo.org/projects/"
"postgis/using_raster_datamanxml/zh_Hans/>\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 5.0\n"

#. Tag: title
#: using_raster_dataman.xml:3
#, no-c-format
msgid "Raster Data Management, Queries, and Applications"
msgstr "栅格数据管理、查询和应用程序"

#. Tag: title
#: using_raster_dataman.xml:5
#, no-c-format
msgid "Loading and Creating Rasters"
msgstr "加载和创建栅格"

#. Tag: para
#: using_raster_dataman.xml:6
#, no-c-format
msgid ""
"For most use cases, you will create PostGIS rasters by loading existing "
"raster files using the packaged <varname>raster2pgsql</varname> raster "
"loader."
msgstr ""
"对于大多数用例，您将通过使用打包的 <varname>raster2pgsql </varname>栅格加载器"
"加载现有栅格文件来创建 PostGIS 栅格。"

#. Tag: title
#: using_raster_dataman.xml:9
#, no-c-format
msgid "Using raster2pgsql to load rasters"
msgstr "使用 raster2pgsql 加载栅格"

#. Tag: para
#: using_raster_dataman.xml:11
#, no-c-format
msgid ""
"The <varname>raster2pgsql</varname> is a raster loader executable that loads "
"GDAL supported raster formats into SQL suitable for loading into a PostGIS "
"raster table. It is capable of loading folders of raster files as well as "
"creating overviews of rasters."
msgstr ""
"<varname>raster2pgsql</varname>是一个用于将 GDAL 支持的栅格格式加载到适合加载"
"到 PostGIS 栅格表的 SQL 的栅格加载器可执行文件。它能够加载文件夹中的栅格文"
"件，同时创建栅格的概览。"

#. Tag: para
#: using_raster_dataman.xml:13
#, no-c-format
msgid ""
"Since the raster2pgsql is compiled as part of PostGIS most often (unless you "
"compile your own GDAL library), the raster types supported by the executable "
"will be the same as those compiled in the GDAL dependency library. To get a "
"list of raster types your particular <varname>raster2pgsql</varname> "
"supports use the <varname>-G</varname> switch."
msgstr ""
"由于 raster2pgsql 最常被编译为 PostGIS 的一部分（除非您编译自己的 GDAL 库），"
"因此可执行文件支持的栅格类型将与 GDAL 依赖库中编译的栅格类型相同。 要获取特"
"定 <varname>raster2pgsql </varname>支持的栅格类型列表，请使用 <varname>-G</"
"varname> 指令。"

#. Tag: para
#: using_raster_dataman.xml:16
#, no-c-format
msgid ""
"When creating overviews of a specific factor from a set of rasters that are "
"aligned, it is possible for the overviews to not align. Visit <link xlink:"
"href=\"http://trac.osgeo.org/postgis/ticket/1764\">http://trac.osgeo.org/"
"postgis/ticket/1764</link> for an example where the overviews do not align."
msgstr ""
"在从一组对齐的栅格创建特定因子的概览时，有可能概览不会对齐。请访问<link "
"xlink:href=\"http://trac.osgeo.org/postgis/ticket/1764\"> http://trac.osgeo."
"org/postgis/ticket/1764 </link>查看一个示例，其中概览未对齐。"

#. Tag: title
#: using_raster_dataman.xml:20
#, no-c-format
msgid "Example Usage"
msgstr "用法示例"

#. Tag: para
#: using_raster_dataman.xml:22
#, no-c-format
msgid ""
"An example session using the loader to create an input file and uploading it "
"chunked in 100x100 tiles might look like this:"
msgstr ""
"使用加载器创建输入文件并将其以 100x100 块分块上传的示例会话可能如下所示："

#. Tag: para
#: using_raster_dataman.xml:27
#, no-c-format
msgid ""
"If you do not specify the schema as part of the target table name, the table "
"will be created in the default schema of the database or user you are "
"connecting with."
msgstr ""
"如果您没有将架构指定为目标表名称的一部分，则该表将在您所连接的数据库或用户的"
"默认架构中创建。"

#. Tag: para
#: using_raster_dataman.xml:30
#, no-c-format
msgid "A conversion and upload can be done all in one step using UNIX pipes:"
msgstr "使用 UNIX 管道可以一步完成转换和上传："

#. Tag: para
#: using_raster_dataman.xml:34
#, no-c-format
msgid ""
"Load rasters Massachusetts state plane meters aerial tiles into a schema "
"called <varname>aerial</varname> and create a full view, 2 and 4 level "
"overview tables, use copy mode for inserting (no intermediary file just "
"straight to db), and -e don't force everything in a transaction (good if you "
"want to see data in tables right away without waiting). Break up the rasters "
"into 128x128 pixel tiles and apply raster constraints. Use copy mode instead "
"of table insert. (-F) Include a field called filename to hold the name of "
"the file the tiles were cut from."
msgstr ""
"将马萨诸塞州平面米制航空瓦片加载到名为<varname>aerial</varname>的架构中，并创"
"建一个全视图，2级和4级概览表，使用复制模式进行插入（没有中间文件，直接到数据"
"库），并且使用“-e”选项来避免强制将所有内容放入一个事务中（如果你希望立即查看"
"表中的数据而不必等待的话）。将栅格分割成128x128像素的瓦片，并应用栅格约束。同"
"时，包括一个名为“filename”的字段，用于存储瓦片所来自的文件的名称。"

#. Tag: para
#: using_raster_dataman.xml:40
#, no-c-format
msgid "The -G commands outputs a list something like"
msgstr "-G 指令输出类似的列表"

#. Tag: title
#: using_raster_dataman.xml:46
#, no-c-format
msgid "raster2pgsql options"
msgstr "raster2pgsql 选项"

#. Tag: term
#: using_raster_dataman.xml:50
#, no-c-format
msgid "<term>-?</term>"
msgstr "<term>-?</term>"

#. Tag: para
#: using_raster_dataman.xml:52
#, no-c-format
msgid ""
"Display help screen. Help will also display if you don't pass in any "
"arguments."
msgstr "显示帮助屏幕。 如果您不传入任何参数，也会显示帮助。"

#. Tag: term
#: using_raster_dataman.xml:59
#, no-c-format
msgid "<term>-G</term>"
msgstr "<term>-G</term>"

#. Tag: para
#: using_raster_dataman.xml:61
#, no-c-format
msgid "Print the supported raster formats."
msgstr "打印支持的栅格格式。"

#. Tag: term
#: using_raster_dataman.xml:68
#, no-c-format
msgid "(c|a|d|p) These are mutually exclusive options:"
msgstr "（c|a|d|p）这些是相互排斥的选项："

#. Tag: term
#: using_raster_dataman.xml:73
#, no-c-format
msgid "<term>-c</term>"
msgstr "<term>-c</term>"

#. Tag: para
#: using_raster_dataman.xml:75
#, no-c-format
msgid ""
"Create new table and populate it with raster(s), <emphasis>this is the "
"default mode</emphasis>"
msgstr "创建新表并用栅格填充它，<emphasis>这是默认模式</emphasis>"

#. Tag: term
#: using_raster_dataman.xml:82
#, no-c-format
msgid "<term>-a</term>"
msgstr "<term>-a</term>"

#. Tag: para
#: using_raster_dataman.xml:84
#, no-c-format
msgid "Append raster(s) to an existing table."
msgstr "将栅格附加到现有表。"

#. Tag: term
#: using_raster_dataman.xml:91
#, no-c-format
msgid "<term>-d</term>"
msgstr "<term>-d</term>"

#. Tag: para
#: using_raster_dataman.xml:93
#, no-c-format
msgid "Drop table, create new one and populate it with raster(s)"
msgstr "删除表，创建新表并用栅格填充它"

#. Tag: term
#: using_raster_dataman.xml:100
#, no-c-format
msgid "<term>-p</term>"
msgstr "<term>-p</term>"

#. Tag: para
#: using_raster_dataman.xml:102
#, no-c-format
msgid "Prepare mode, only create the table."
msgstr "准备模式，只创建表。"

#. Tag: term
#: using_raster_dataman.xml:113
#, no-c-format
msgid ""
"Raster processing: Applying constraints for proper registering in raster "
"catalogs"
msgstr "栅格处理：应用约束以在栅格目录中正确注册"

#. Tag: term
#: using_raster_dataman.xml:118
#, no-c-format
msgid "<term>-C</term>"
msgstr "<term>-C</term>"

#. Tag: para
#: using_raster_dataman.xml:120
#, no-c-format
msgid ""
"Apply raster constraints -- srid, pixelsize etc. to ensure raster is "
"properly registered in <varname>raster_columns</varname> view."
msgstr ""
"应用栅格约束——srid、像素大小等，以确保栅格在<varname>raster_columns</"
"varname> 视图中正确配准。"

#. Tag: term
#: using_raster_dataman.xml:126
#, no-c-format
msgid "<term>-x</term>"
msgstr "<term>-x</term>"

#. Tag: para
#: using_raster_dataman.xml:128
#, no-c-format
msgid ""
"Disable setting the max extent constraint. Only applied if -C flag is also "
"used."
msgstr "禁用设置最大范围约束。 仅当还使用 -C 指令时才适用。"

#. Tag: term
#: using_raster_dataman.xml:134
#, no-c-format
msgid "<term>-r</term>"
msgstr "<term>-r</term>"

#. Tag: para
#: using_raster_dataman.xml:136
#, no-c-format
msgid ""
"Set the constraints (spatially unique and coverage tile) for regular "
"blocking. Only applied if -C flag is also used."
msgstr "设置规范块约束（空间唯一和详尽的切片）。 仅当还使用 -C 指令时才适用。"

#. Tag: term
#: using_raster_dataman.xml:147
#, no-c-format
msgid ""
"Raster processing: Optional parameters used to manipulate input raster "
"dataset"
msgstr "栅格处理：用于操作输入栅格数据集的可选参数"

#. Tag: term
#: using_raster_dataman.xml:152
#, no-c-format
msgid "-s &lt;SRID&gt;"
msgstr "-s &lt;SRID&gt;"

#. Tag: para
#: using_raster_dataman.xml:154
#, no-c-format
msgid ""
"Assign output raster with specified SRID. If not provided or is zero, "
"raster's metadata will be checked to determine an appropriate SRID."
msgstr ""
"使用指定的 SRID 分配输出栅格。 如果未提供或为零，则将检查栅格的元数据以确定适"
"当的 SRID。"

#. Tag: term
#: using_raster_dataman.xml:161
#, no-c-format
msgid "-b BAND"
msgstr "-b BAND"

#. Tag: para
#: using_raster_dataman.xml:163
#, no-c-format
msgid ""
"Index (1-based) of band to extract from raster. For more than one band "
"index, separate with comma (,). If unspecified, all bands of raster will be "
"extracted."
msgstr ""
"从栅格中提取的波段索引（从 1 开始）。 对于多个波段索引，用逗号（,）分隔。 如"
"果未指定，则将提取栅格的所有波段。"

#. Tag: term
#: using_raster_dataman.xml:171
#, no-c-format
msgid "-t TILE_SIZE"
msgstr "-t TILE_SIZE"

#. Tag: para
#: using_raster_dataman.xml:173
#, no-c-format
msgid ""
"Cut raster into tiles to be inserted one per table row. <varname>TILE_SIZE</"
"varname> is expressed as WIDTHxHEIGHT or set to the value \"auto\" to allow "
"the loader to compute an appropriate tile size using the first raster and "
"applied to all rasters."
msgstr ""
"将光栅切割成图块，以便在每个表行插入一个图块。<varname> TILE_SIZE</varname> "
"表示为 WIDTHxHEIGHT 或设置为值“auto”，以允许加载程序使用第一个栅格计算适当的"
"切片大小并将其应用于所有栅格。"

#. Tag: term
#: using_raster_dataman.xml:180
#, no-c-format
msgid "<term>-P</term>"
msgstr "<term>-P</term>"

#. Tag: para
#: using_raster_dataman.xml:182
#, no-c-format
msgid ""
"Pad right-most and bottom-most tiles to guarantee that all tiles have the "
"same width and height."
msgstr "填充最右侧和最底部的图块，以保证所有图块具有相同的宽度和高度。"

#. Tag: term
#: using_raster_dataman.xml:192
#, no-c-format
msgid "-R, --register"
msgstr "-R, --register"

#. Tag: para
#: using_raster_dataman.xml:194
#, no-c-format
msgid "Register the raster as a filesystem (out-db) raster."
msgstr "将栅格注册为文件系统 (out-db) 栅格。"

#. Tag: para
#: using_raster_dataman.xml:195
#, no-c-format
msgid ""
"Only the metadata of the raster and path location to the raster is stored in "
"the database (not the pixels)."
msgstr "仅栅格的元数据和栅格的路径位置存储在数据库中（而不是像素）。"

#. Tag: term
#: using_raster_dataman.xml:200
#, no-c-format
msgid "-l OVERVIEW_FACTOR"
msgstr "-l OVERVIEW_FACTOR"

#. Tag: para
#: using_raster_dataman.xml:201
#, no-c-format
msgid ""
"Create overview of the raster. For more than one factor, separate with "
"comma(,). Overview table name follows the pattern o_<varname>overview "
"factor</varname>_<varname>table</varname>, where <varname>overview factor</"
"varname> is a placeholder for numerical overview factor and <varname>table</"
"varname> is replaced with the base table name. Created overview is stored in "
"the database and is not affected by -R. Note that your generated sql file "
"will contain both the main table and overview tables."
msgstr ""
"创建栅格的概览。 对于多个因素，用逗号（，）分隔。 概览表名称遵循 "
"o_<varname>overview Factor</varname>_<varname>table</varname> 模式，其中"
"<varname>概览因子</varname>是数字概览因子的占位符，<varname>表</varname>将替"
"换为基表名称。 创建的概述存储在数据库中，不受-R影响。 请注意，生成的 sql 文件"
"将包含主表和概览表。"

#. Tag: term
#: using_raster_dataman.xml:209
#, no-c-format
msgid "-N NODATA"
msgstr "-N NODATA"

#. Tag: para
#: using_raster_dataman.xml:211
#, no-c-format
msgid "NODATA value to use on bands without a NODATA value."
msgstr "NODATA 值用于没有 NODATA 值的带。"

#. Tag: term
#: using_raster_dataman.xml:223
#, no-c-format
msgid "Optional parameters used to manipulate database objects"
msgstr "用于操作数据库对象的可选参数"

#. Tag: term
#: using_raster_dataman.xml:228
#, no-c-format
msgid "-f COLUMN"
msgstr "-f COLUMN"

#. Tag: para
#: using_raster_dataman.xml:230
#, no-c-format
msgid "Specify name of destination raster column, default is 'rast'"
msgstr "指定目标栅格列的名称，默认为“rast”"

#. Tag: term
#: using_raster_dataman.xml:236
#, no-c-format
msgid "<term>-F</term>"
msgstr "<term>-F</term>"

#. Tag: para
#: using_raster_dataman.xml:238
#, no-c-format
msgid "Add a column with the name of the file"
msgstr "添加包含文件名的列"

#. Tag: term
#: using_raster_dataman.xml:243
#, no-c-format
msgid "-n COLUMN"
msgstr "-n COLUMN"

#. Tag: para
#: using_raster_dataman.xml:245
#, no-c-format
msgid "Specify the name of the filename column. Implies -F."
msgstr "指定文件名列的名称。 意味着-F。"

#. Tag: term
#: using_raster_dataman.xml:250
#, no-c-format
msgid "<term>-q</term>"
msgstr "<term>-q</term>"

#. Tag: para
#: using_raster_dataman.xml:252
#, no-c-format
msgid "Wrap PostgreSQL identifiers in quotes."
msgstr "将 PostgreSQL 标识符括在引号中。"

#. Tag: term
#: using_raster_dataman.xml:257
#, no-c-format
msgid "<term>-I</term>"
msgstr "<term>-I</term>"

#. Tag: para
#: using_raster_dataman.xml:259
#, no-c-format
msgid "Create a GiST index on the raster column."
msgstr "在栅格列上创建 GiST 索引。"

#. Tag: term
#: using_raster_dataman.xml:266
#, no-c-format
msgid "<term>-M</term>"
msgstr "<term>-M</term>"

#. Tag: para
#: using_raster_dataman.xml:268
#, no-c-format
msgid "Vacuum analyze the raster table."
msgstr "真空分析栅格表。"

#. Tag: term
#: using_raster_dataman.xml:276
#, no-c-format
msgid "<term>-k</term>"
msgstr "<term>-k</term>"

#. Tag: para
#: using_raster_dataman.xml:278
#, no-c-format
msgid ""
"Keeps empty tiles and skips NODATA value checks for each raster band. Note "
"you save time in checking, but could end up with far more junk rows in your "
"database and those junk rows are not marked as empty tiles."
msgstr ""
"保留空的瓦片并跳过每个光栅波段的NODATA值检查。请注意，这样可以节省检查的时"
"间，但可能会导致数据库中出现更多的垃圾行，并且这些垃圾行不会标记为空的瓦片。"

#. Tag: term
#: using_raster_dataman.xml:287
#, no-c-format
msgid "-T tablespace"
msgstr "-T tablespace"

#. Tag: para
#: using_raster_dataman.xml:289
#, no-c-format
msgid ""
"Specify the tablespace for the new table. Note that indices (including the "
"primary key) will still use the default tablespace unless the -X flag is "
"also used."
msgstr ""
"指定新表的表空间。 请注意，索引（包括主键）仍将使用默认表空间，除非还使用了 -"
"X 标志。"

#. Tag: term
#: using_raster_dataman.xml:298
#, no-c-format
msgid "-X tablespace"
msgstr "-X tablespace"

#. Tag: para
#: using_raster_dataman.xml:300
#, no-c-format
msgid ""
"Specify the tablespace for the table's new index. This applies to the "
"primary key and the spatial index if the -I flag is used."
msgstr "指定表的新索引的表空间。 如果使用 -I 标志，这适用于主键和空间索引。"

#. Tag: term
#: using_raster_dataman.xml:309
#, no-c-format
msgid "-Y max_rows_per_copy=50"
msgstr "-Y max_rows_per_copy=50"

#. Tag: para
#: using_raster_dataman.xml:311
#, no-c-format
msgid ""
"Use copy statements instead of insert statements. Optionally specify "
"<varname>max_rows_per_copy</varname>; default 50 when not specified."
msgstr ""
"使用复制语句而不是插入语句。 可以选择指定 <varname>max_rows_per_copy</"
"varname>； 未指定时默认为 50。"

#. Tag: term
#: using_raster_dataman.xml:323
#, no-c-format
msgid "<term>-e</term>"
msgstr "<term>-e</term>"

#. Tag: para
#: using_raster_dataman.xml:324
#, no-c-format
msgid "Execute each statement individually, do not use a transaction."
msgstr "单独执行每条语句，不使用事务。"

#. Tag: term
#: using_raster_dataman.xml:328
#, no-c-format
msgid "-E ENDIAN"
msgstr "-E ENDIAN"

#. Tag: para
#: using_raster_dataman.xml:329
#, no-c-format
msgid ""
"Control endianness of generated binary output of raster; specify 0 for XDR "
"and 1 for NDR (default); only NDR output is supported now"
msgstr ""
"控制生成的光栅二进制输出的字节顺序； 为 XDR 指定 0，为 NDR 指定 1（默认）； "
"现在仅支持 NDR 输出"

#. Tag: term
#: using_raster_dataman.xml:333
#, no-c-format
msgid "-V version"
msgstr "-V version"

#. Tag: para
#: using_raster_dataman.xml:334
#, no-c-format
msgid ""
"Specify version of output format. Default is 0. Only 0 is supported at this "
"time."
msgstr "指定输出格式的版本。 默认为0。目前仅支持0。"

#. Tag: title
#: using_raster_dataman.xml:345
#, no-c-format
msgid "Creating rasters using PostGIS raster functions"
msgstr "使用 PostGIS 栅格函数创建栅格"

#. Tag: para
#: using_raster_dataman.xml:346
#, no-c-format
msgid ""
"On many occasions, you'll want to create rasters and raster tables right in "
"the database. There are a plethora of functions to do that. The general "
"steps to follow."
msgstr ""
"在许多情况下，您需要直接在数据库中创建栅格和栅格表。 有很多函数可以做到这一"
"点。 要遵循的一般步骤。"

#. Tag: para
#: using_raster_dataman.xml:348
#, no-c-format
msgid ""
"Create a table with a raster column to hold the new raster records which can "
"be accomplished with:"
msgstr "创建一个包含栅格列的表来保存新的栅格记录，可以通过以下方式完成："

#. Tag: para
#: using_raster_dataman.xml:352
#, no-c-format
msgid ""
"There are many functions to help with that goal. If you are creating rasters "
"not as a derivative of other rasters, you will want to start with: <xref "
"linkend=\"RT_ST_MakeEmptyRaster\"/>, followed by <xref "
"linkend=\"RT_ST_AddBand\"/>"
msgstr ""
"有许多功能可以帮助实现这一目标。 如果您创建的栅格不是其他栅格的衍生品，则需要"
"从以下位置开始：<xref linkend=\"RT_ST_MakeEmptyRaster\"/>，然后是 <xref "
"linkend=\"RT_ST_AddBand\"/>"

#. Tag: para
#: using_raster_dataman.xml:354
#, no-c-format
msgid ""
"You can also create rasters from geometries. To achieve that you'll want to "
"use <xref linkend=\"RT_ST_AsRaster\"/> perhaps accompanied with other "
"functions such as <xref linkend=\"RT_ST_Union\"/> or <xref "
"linkend=\"RT_ST_MapAlgebraFct2\"/> or any of the family of other map algebra "
"functions."
msgstr ""
"您还可以从几何图形创建栅格。 为了实现这一点，您可能需要使用 <xref "
"linkend=\"RT_ST_AsRaster\"/> 以及其他函数，例如 <xref "
"linkend=\"RT_ST_Union\"/> 或 <xref linkend=\"RT_ST_MapAlgebraFct2\"/>或任何其"
"他地图代数函数系列。"

#. Tag: para
#: using_raster_dataman.xml:356
#, no-c-format
msgid ""
"There are even many more options for creating new raster tables from "
"existing tables. For example you can create a raster table in a different "
"projection from an existing one using <xref linkend=\"RT_ST_Transform\"/>"
msgstr ""
"甚至还有更多选项可用于从现有表创建新栅格表。 例如，您可以使用 <xref "
"linkend=\"RT_ST_Transform\"/>在与现有投影不同的投影中创建栅格表"

#. Tag: para
#: using_raster_dataman.xml:358
#, no-c-format
msgid ""
"Once you are done populating your table initially, you'll want to create a "
"spatial index on the raster column with something like:"
msgstr "最初填充表后，您将需要在栅格列上创建一个空间索引，如下所示："

#. Tag: para
#: using_raster_dataman.xml:360
#, no-c-format
msgid ""
"Note the use of <xref linkend=\"RT_ST_ConvexHull\"/> since most raster "
"operators are based on the convex hull of the rasters."
msgstr ""
"请注意 <xref linkend=\"RT_ST_ConvexHull\"/>的使用，因为大多数栅格运算符都基于"
"栅格的凸包。"

#. Tag: para
#: using_raster_dataman.xml:361
#, no-c-format
msgid ""
"Pre-2.0 versions of PostGIS raster were based on the envelop rather than the "
"convex hull. For the spatial indexes to work properly you'll need to drop "
"those and replace with convex hull based index."
msgstr ""
"PostGIS 栅格 2.0 之前的版本基于最小外接矩形而不是凸包。 为了使空间索引正常工"
"作，您需要删除它们并替换为基于凸包的索引。"

#. Tag: para
#: using_raster_dataman.xml:362
#, no-c-format
msgid ""
"Apply raster constraints using <xref linkend=\"RT_AddRasterConstraints\"/>"
msgstr "使用 <xref linkend=\"RT_AddRasterConstraints\"/>应用栅格约束"

#. Tag: title
#: using_raster_dataman.xml:367
#, no-c-format
msgid "Using \"out db\" cloud rasters"
msgstr "使用“out db”云栅格"

#. Tag: para
#: using_raster_dataman.xml:368
#, no-c-format
msgid ""
"The <varname>raster2pgsql</varname> tool uses GDAL to access raster data, "
"and can take advantage of a key GDAL feature: the ability to read from "
"rasters that are <link xlink:href=\"https://gdal.org/user/"
"virtual_file_systems.html#network-based-file-systems\">stored remotely</"
"link> in cloud \"object stores\" (e.g. AWS S3, Google Cloud Storage)."
msgstr ""
"<varname>raster2pgsql</varname> 工具使用 GDAL 访问栅格数据，并且可以利用 "
"GDAL 的一个关键功能：能够从<link xlink:href=\"https://gdal.org/user/"
"virtual_file_systems.html#network-based-file-systems\">远程存储</link>在云“对"
"象存储”（例如 AWS S3、Google Cloud Storage）中的栅格中读取数据。"

#. Tag: para
#: using_raster_dataman.xml:372
#, no-c-format
msgid ""
"Efficient use of cloud stored rasters requires the use of a \"cloud "
"optimized\" format. The most well-known and widely used is the \"<link xlink:"
"href=\"https://gdal.org/drivers/raster/cog.html\">cloud optimized GeoTIFF</"
"link>\" format. Using a non-cloud format, like a JPEG, or an un-tiled TIFF "
"will result in very poor performance, as the system will have to download "
"the entire raster each time it needs to access a subset."
msgstr ""
"有效使用云存储栅格需要使用“云优化”格式。 最知名和最广泛使用的是“<link xlink:"
"href=\"https://gdal.org/drivers/raster/cog.html\">云优化的 GeoTIFF</link>”格"
"式。 使用非云格式（例如 JPEG 或未平铺的 TIFF）将导致性能非常差，因为系统每次"
"需要访问子集时都必须下载整个栅格。"

#. Tag: para
#: using_raster_dataman.xml:375
#, no-c-format
msgid ""
"First, load your raster into the cloud storage of your choice. Once it is "
"loaded, you will have a URI to access it with, either an \"http\" URI, or "
"sometimes a URI specific to the service. (e.g., \"s3://bucket/object\"). To "
"access non-public buckets, you will need to supply GDAL config options to "
"authenticate your connection. Note that this command is <emphasis>reading</"
"emphasis> from the cloud raster and <emphasis>writing</emphasis> to the "
"database."
msgstr ""
"首先，将栅格加载到您选择的云存储中。 一旦加载，您将有一个 URI 来访问它，可以"
"是“http”URI，有时也可以是特定于服务的 URI。 （例如，“s3://bucket/object”）。 "
"要访问非公共存储桶，您需要提供 GDAL 配置选项来验证您的连接。 请注意，此命令是"
"从云栅格<emphasis>读取</emphasis>并<emphasis>写入</emphasis>数据库。"

#. Tag: para
#: using_raster_dataman.xml:379
#, no-c-format
msgid ""
"Once the table is loaded, you need to give the database permission to read "
"from remote rasters, by setting two permissions, <xref "
"linkend=\"postgis_enable_outdb_rasters\"/> and <xref "
"linkend=\"postgis_gdal_enabled_drivers\"/>."
msgstr ""
"加载表后，您需要通过设置两个权限（<xref "
"linkend=\"postgis_enable_outdb_rasters\"/> 和<xref "
"linkend=\"postgis_gdal_enabled_drivers\"/>）来授予数据库从远程栅格读取的权"
"限。"

#. Tag: para
#: using_raster_dataman.xml:383
#, no-c-format
msgid ""
"To make the changes sticky, set them directly on your database. You will "
"need to re-connect to experience the new settings."
msgstr ""
"为了使更改生效并持久化，直接在您的数据库上进行设置。您将需要重新连接以体验新"
"的设置。"

#. Tag: para
#: using_raster_dataman.xml:387
#, no-c-format
msgid ""
"For non-public rasters, you may have to provide access keys to read from the "
"cloud rasters. The same keys you used to write the <varname>raster2pgsql</"
"varname> call can be set for use inside the database, with the <xref "
"linkend=\"postgis_gdal_vsi_options\"/> configuration. Note that multiple "
"options can be set by space-separating the <varname>key=value</varname> "
"pairs."
msgstr ""
"对于非公共栅格，您可能必须提供访问密钥才能从云栅格中读取。 您可以使用 <xref "
"linkend=\"postgis_gdal_vsi_options\"/>配置将用于编写<varname> raster2pgsql </"
"varname>调用的相同键设置为在数据库内部使用。 请注意，可以通过空格分隔"
"<varname>键=值对</varname>来设置多个选项。"

#. Tag: para
#: using_raster_dataman.xml:391
#, no-c-format
msgid ""
"Once you have the data loaded and permissions set you can interact with the "
"raster table like any other raster table, using the same functions. The "
"database will handle all the mechanics of connecting to the cloud data when "
"it needs to read pixel data."
msgstr ""
"加载数据并设置权限后，您可以使用相同的功能像任何其他栅格表一样与栅格表进行交"
"互。 当需要读取像素数据时，数据库将处理连接到云数据的所有机制。"

#. Tag: title
#: using_raster_dataman.xml:397
#, no-c-format
msgid "Raster Catalogs"
msgstr "光栅目录"

#. Tag: para
#: using_raster_dataman.xml:398
#, no-c-format
msgid ""
"There are two raster catalog views that come packaged with PostGIS. Both "
"views utilize information embedded in the constraints of the raster tables. "
"As a result the catalog views are always consistent with the raster data in "
"the tables since the constraints are enforced."
msgstr ""
"PostGIS 附带了两个栅格目录视图。 两个视图都利用嵌入在栅格表约束中的信息。 因"
"此，由于强制实施了约束，目录视图始终与表中的栅格数据一致。"

#. Tag: para
#: using_raster_dataman.xml:402
#, no-c-format
msgid ""
"<varname>raster_columns</varname> this view catalogs all the raster table "
"columns in your database."
msgstr ""
"<varname>raster_columns</varname> 此视图对数据库中的所有栅格表列进行编目。"

#. Tag: para
#: using_raster_dataman.xml:405
#, no-c-format
msgid ""
"<varname>raster_overviews</varname> this view catalogs all the raster table "
"columns in your database that serve as overviews for a finer grained table. "
"Tables of this type are generated when you use the <varname>-l</varname> "
"switch during load."
msgstr ""
"<varname>raster_overviews </varname>此视图对数据库中的所有栅格表列进行编目，"
"这些列用作更细粒度表的概述。 当您在加载期间使用<varname> -l </varname>开关"
"时，会生成这种类型的表。"

#. Tag: title
#: using_raster_dataman.xml:409
#, no-c-format
msgid "Raster Columns Catalog"
msgstr "栅格列目录"

#. Tag: para
#: using_raster_dataman.xml:410
#, no-c-format
msgid ""
"The <varname>raster_columns</varname> is a catalog of all raster table "
"columns in your database that are of type raster. It is a view utilizing the "
"constraints on the tables so the information is always consistent even if "
"you restore one raster table from a backup of another database. The "
"following columns exist in the <varname>raster_columns</varname> catalog."
msgstr ""
"<varname>raster_columns</varname> 是数据库中所有栅格类型的栅格表列的目录。 它"
"是一种利用表约束的视图，因此即使您从另一个数据库的备份恢复一个栅格表，信息也"
"始终保持一致。 <varname>raster_columns </varname>目录中存在以下列。"

#. Tag: para
#: using_raster_dataman.xml:412
#, no-c-format
msgid ""
"If you created your tables not with the loader or forgot to specify the "
"<varname>-C</varname> flag during load, you can enforce the constraints "
"after the fact using <xref linkend=\"RT_AddRasterConstraints\"/> so that the "
"<varname>raster_columns</varname> catalog registers the common information "
"about your raster tiles."
msgstr ""
"如果您未使用加载器创建表或忘记在加载期间指定 <varname>-C </varname>标志，则可"
"以在事后使用 <xref linkend=\"RT_AddRasterConstraints\"/>强制执行约束，以便 "
"<varname>raster_columns </varname>目录注册有关栅格切片的通用信息。"

#. Tag: para
#: using_raster_dataman.xml:417
#, no-c-format
msgid ""
"<varname>r_table_catalog</varname> The database the table is in. This will "
"always read the current database."
msgstr ""
"<varname>r_table_catalog </varname>表所在的数据库。这将始终读取当前数据库。"

#. Tag: para
#: using_raster_dataman.xml:420
#, no-c-format
msgid ""
"<varname>r_table_schema</varname> The database schema the raster table "
"belongs to."
msgstr "<varname>r_table_schema </varname>栅格表所属的数据库模式。"

#. Tag: para
#: using_raster_dataman.xml:423
#, no-c-format
msgid "<varname>r_table_name</varname> raster table"
msgstr "<varname>r_table_name</varname> 栅格表"

#. Tag: para
#: using_raster_dataman.xml:426
#, no-c-format
msgid ""
"<varname>r_raster_column</varname> the column in the <varname>r_table_name</"
"varname> table that is of type raster. There is nothing in PostGIS "
"preventing you from having multiple raster columns per table so its possible "
"to have a raster table listed multiple times with a different raster column "
"for each."
msgstr ""
"<varname>r_raster_column </varname>在<varname>r_table_name</varname> 表中栅格"
"类型的列。 PostGIS 中没有任何内容可以阻止您在每个表中拥有多个栅格列，因此可以"
"多次列出一个栅格表，并且每个表具有不同的栅格列。"

#. Tag: para
#: using_raster_dataman.xml:429
#, no-c-format
msgid ""
"<varname>srid</varname> The spatial reference identifier of the raster. "
"Should be an entry in the <xref linkend=\"spatial_ref_sys\"/>."
msgstr ""
"<varname>srid </varname>栅格的空间参考标识符。 应该是<xref "
"linkend=\"spatial_ref_sys\"/>中的条目。"

#. Tag: para
#: using_raster_dataman.xml:432
#, no-c-format
msgid ""
"<varname>scale_x</varname> The scaling between geometric spatial coordinates "
"and pixel. This is only available if all tiles in the raster column have the "
"same <varname>scale_x</varname> and this constraint is applied. Refer to "
"<xref linkend=\"RT_ST_ScaleX\"/> for more details."
msgstr ""
"<varname>scale_x </varname>几何空间坐标与像素之间的缩放比例。 仅当栅格列中的"
"所有切片具有相同的<varname>scale_x</varname>并且应用此约束时，此功能才可用。 "
"有关更多详细信息，请参阅 <xref linkend=\"RT_ST_ScaleX\"/>。"

#. Tag: para
#: using_raster_dataman.xml:435
#, no-c-format
msgid ""
"<varname>scale_y</varname> The scaling between geometric spatial coordinates "
"and pixel. This is only available if all tiles in the raster column have the "
"same <varname>scale_y</varname> and the <varname>scale_y</varname> "
"constraint is applied. Refer to <xref linkend=\"RT_ST_ScaleY\"/> for more "
"details."
msgstr ""
"<varname>scale_y </varname>几何空间坐标与像素之间的缩放比例。 仅当栅格列中的"
"所有切片具有相同的<varname>scale_y</varname>并且应用了<varname>scale_y</"
"varname>约束时，此功能才可用。 有关详细信息，请参阅 <xref "
"linkend=\"RT_ST_ScaleY\"/>。"

#. Tag: para
#: using_raster_dataman.xml:438
#, no-c-format
msgid ""
"<varname>blocksize_x</varname> The width (number of pixels across) of each "
"raster tile . Refer to <xref linkend=\"RT_ST_Width\"/> for more details."
msgstr ""
"<varname>blocksize_x </varname>每个栅格图块的宽度（跨像素数）。 有关更多详细"
"信息，请参阅<xref linkend=\"RT_ST_Width\"/>。"

#. Tag: para
#: using_raster_dataman.xml:441
#, no-c-format
msgid ""
"<varname>blocksize_y</varname> The width (number of pixels down) of each "
"raster tile . Refer to <xref linkend=\"RT_ST_Height\"/> for more details."
msgstr ""
"<varname>blocksize_y </varname>每个栅格图块的宽度（向下的像素数）。 有关更多"
"详细信息，请参阅<xref linkend=\"RT_ST_Height\"/>。"

#. Tag: para
#: using_raster_dataman.xml:444
#, no-c-format
msgid ""
"<varname>same_alignment</varname> A boolean that is true if all the raster "
"tiles have the same alignment . Refer to <xref "
"linkend=\"RT_ST_SameAlignment\"/> for more details."
msgstr ""
"<varname>same_alignment </varname>一个布尔值，如果所有栅格图块具有相同的对齐"
"方式，则该值为 true。 有关更多详细信息，请参阅<xref "
"linkend=\"RT_ST_SameAlignment\"/>。"

#. Tag: para
#: using_raster_dataman.xml:447
#, no-c-format
msgid ""
"<varname>regular_blocking</varname> If the raster column has the spatially "
"unique and coverage tile constraints, the value with be TRUE. Otherwise, it "
"will be FALSE."
msgstr ""
"<varname>Regular_blocking</varname> 如果栅格列具有空间唯一性和覆盖范围切片约"
"束，则该值为 TRUE。 否则，它将是 FALSE。"

#. Tag: para
#: using_raster_dataman.xml:450
#, no-c-format
msgid ""
"<varname>num_bands</varname> The number of bands in each tile of your raster "
"set. This is the same information as what is provided by"
msgstr ""
"<varname>num_bands </varname>栅格集中每个切片中的波段数。 这与 ST_NumBands 提"
"供的信息相同"

#. Tag: para
#: using_raster_dataman.xml:453
#, no-c-format
msgid ""
"<varname>pixel_types</varname> An array defining the pixel type for each "
"band. You will have the same number of elements in this array as you have "
"number of bands. The pixel_types are one of the following defined in <xref "
"linkend=\"RT_ST_BandPixelType\"/>."
msgstr ""
"<varname>Pixel_types</varname> 定义每个波段的像素类型的数组。 该数组中的元素"
"数量与波段的数量相同。 Pixel_types 是 <xref linkend=\"RT_ST_BandPixelType\"/"
"> 中定义的以下类型之一。"

#. Tag: para
#: using_raster_dataman.xml:456
#, no-c-format
msgid ""
"<varname>nodata_values</varname> An array of double precision numbers "
"denoting the <varname>nodata_value</varname> for each band. You will have "
"the same number of elements in this array as you have number of bands. These "
"numbers define the pixel value for each band that should be ignored for most "
"operations. This is similar information provided by <xref "
"linkend=\"RT_ST_BandNoDataValue\"/>."
msgstr ""
"<varname>nodata_values</varname> 双精度数字数组，表示每个波段的<varname> "
"nodata_value</varname>。 该数组中的元素数量与带的数量相同。 这些数字定义了大"
"多数操作中应忽略的每个波段的像素值。 这与<xref "
"linkend=\"RT_ST_BandNoDataValue\"/> 提供的信息类似。"

#. Tag: para
#: using_raster_dataman.xml:459
#, no-c-format
msgid ""
"<varname>out_db</varname> An array of boolean flags indicating if the raster "
"bands data is maintained outside the database. You will have the same number "
"of elements in this array as you have number of bands."
msgstr ""
"<varname>out_db </varname>布尔标志数组，指示栅格波段数据是否在数据库外部维"
"护。 该数组中的元素数量与带的数量相同。"

#. Tag: para
#: using_raster_dataman.xml:462
#, no-c-format
msgid ""
"<varname>extent</varname> This is the extent of all the raster rows in your "
"raster set. If you plan to load more data that will change the extent of the "
"set, you'll want to run the <xref linkend=\"RT_DropRasterConstraints\"/> "
"function before load and then reapply constraints with <xref "
"linkend=\"RT_AddRasterConstraints\"/> after load."
msgstr ""
"<varname>extent</varname>这是栅格集中所有栅格行的范围。 如果您计划加载更多数"
"据来更改集的范围，则需要在加载之前运行 <xref "
"linkend=\"RT_DropRasterConstraints\"/> 函数，然后在加载后使用<xref "
"linkend=\"RT_AddRasterConstraints\"/> 重新应用约束。"

#. Tag: para
#: using_raster_dataman.xml:465
#, no-c-format
msgid ""
"<varname>spatial_index</varname> A boolean that is true if raster column has "
"a spatial index."
msgstr ""
"<varname>Spatial_index </varname>如果栅格列具有空间索引，则为 true 的布尔值。"

#. Tag: title
#: using_raster_dataman.xml:470
#, no-c-format
msgid "Raster Overviews"
msgstr "光栅概述"

#. Tag: para
#: using_raster_dataman.xml:471
#, no-c-format
msgid ""
"<varname>raster_overviews</varname> catalogs information about raster table "
"columns used for overviews and additional information about them that is "
"useful to know when utilizing overviews. Overview tables are cataloged in "
"both <varname>raster_columns</varname> and <varname>raster_overviews</"
"varname> because they are rasters in their own right but also serve an "
"additional special purpose of being a lower resolution caricature of a "
"higher resolution table. These are generated along-side the main raster "
"table when you use the <varname>-l</varname> switch in raster loading or can "
"be generated manually using <xref linkend=\"RT_AddOverviewConstraints\"/>."
msgstr ""
"<varname>raster_overviews</varname> 目录有关用于概览的栅格表列的信息以及在使"
"用概览时了解的有用的附加信息。 概览表在 <varname>raster_columns</varname> 和 "
"<varname>raster_overviews </varname>中进行编目，因为它们本身就是栅格，但还具"
"有作为高分辨率表的较低分辨率的漫画化图像的额外特殊用途。 当您在栅格加载中使"
"用 <varname>-l </varname>开关时，它们会与主栅格表一起生成，或者可以使用 "
"<xref linkend=\"RT_AddOverviewConstraints\"/>手动生成。"

#. Tag: para
#: using_raster_dataman.xml:472
#, no-c-format
msgid ""
"Overview tables contain the same constraints as other raster tables as well "
"as additional informational only constraints specific to overviews."
msgstr "概览表包含与其他栅格表相同的约束以及特定于概览的附加信息约束。"

#. Tag: para
#: using_raster_dataman.xml:473
#, no-c-format
msgid ""
"The information in <varname>raster_overviews</varname> does not duplicate "
"the information in <varname>raster_columns</varname>. If you need the "
"information about an overview table present in <varname>raster_columns</"
"varname> you can join the <varname>raster_overviews</varname> and "
"<varname>raster_columns</varname> together to get the full set of "
"information you need."
msgstr ""
"<varname>raster_overviews</varname> 中的信息与<varname> raster_columns </"
"varname>中的信息不重复。 如果您需要有关 <varname>raster_columns </varname>中"
"存在的概览表的信息，您可以将 <varname>raster_overviews</varname> 和 "
"<varname>raster_columns </varname>连接在一起以获得所需的完整信息集。"

#. Tag: para
#: using_raster_dataman.xml:474
#, no-c-format
msgid "Two main reasons for overviews are:"
msgstr "进行概览的两个主要原因是："

#. Tag: para
#: using_raster_dataman.xml:476
#, no-c-format
msgid ""
"Low resolution representation of the core tables commonly used for fast "
"mapping zoom-out."
msgstr "通常用于快速映射缩小的核心表的低分辨率表示。"

#. Tag: para
#: using_raster_dataman.xml:477
#, no-c-format
msgid ""
"Computations are generally faster to do on them than their higher resolution "
"parents because there are fewer records and each pixel covers more "
"territory. Though the computations are not as accurate as the high-res "
"tables they support, they can be sufficient in many rule-of-thumb "
"computations."
msgstr ""
"它们的计算速度通常比其更高分辨率的父级更快，因为记录更少，每个像素覆盖更多区"
"域。 尽管计算不如它们支持的高分辨率表那么准确，但它们在许多粗略计算中已经足够"
"了。"

#. Tag: para
#: using_raster_dataman.xml:480
#, no-c-format
msgid ""
"The <varname>raster_overviews</varname> catalog contains the following "
"columns of information."
msgstr "<varname>raster_overviews</varname> 目录包含以下信息。"

#. Tag: para
#: using_raster_dataman.xml:483
#, no-c-format
msgid ""
"<varname>o_table_catalog</varname> The database the overview table is in. "
"This will always read the current database."
msgstr ""
"<varname>o_table_catalog </varname>概览表所在的数据库。这将始终读取当前数据"
"库。"

#. Tag: para
#: using_raster_dataman.xml:486
#, no-c-format
msgid ""
"<varname>o_table_schema</varname> The database schema the overview raster "
"table belongs to."
msgstr "<varname>o_table_schema</varname> 概览栅格表所属的数据库架构。"

#. Tag: para
#: using_raster_dataman.xml:489
#, no-c-format
msgid "<varname>o_table_name</varname> raster overview table name"
msgstr "<varname>o_table_name </varname>栅格概览表名称"

#. Tag: para
#: using_raster_dataman.xml:492
#, no-c-format
msgid ""
"<varname>o_raster_column</varname> the raster column in the overview table."
msgstr "<varname>o_raster_column </varname>概览表中的栅格列。"

#. Tag: para
#: using_raster_dataman.xml:496
#, no-c-format
msgid ""
"<varname>r_table_catalog</varname> The database the raster table that this "
"overview services is in. This will always read the current database."
msgstr ""
"<varname>r_table_catalog</varname> 该概览服务所在的栅格表所在的数据库。这将始"
"终读取当前数据库。"

#. Tag: para
#: using_raster_dataman.xml:499
#, no-c-format
msgid ""
"<varname>r_table_schema</varname> The database schema the raster table that "
"this overview services belongs to."
msgstr "<varname>r_table_schema </varname>此概览服务所属的栅格表的数据库架构。"

#. Tag: para
#: using_raster_dataman.xml:502
#, no-c-format
msgid ""
"<varname>r_table_name</varname> raster table that this overview services."
msgstr "<varname>r_table_name</varname> 此概览服务的栅格表。"

#. Tag: para
#: using_raster_dataman.xml:505
#, no-c-format
msgid ""
"<varname>r_raster_column</varname> the raster column that this overview "
"column services."
msgstr "<varname>r_raster_column</varname> 此概览列服务的栅格列。"

#. Tag: para
#: using_raster_dataman.xml:508
#, no-c-format
msgid ""
"<varname>overview_factor</varname> - this is the pyramid level of the "
"overview table. The higher the number the lower the resolution of the table. "
"raster2pgsql if given a folder of images, will compute overview of each "
"image file and load separately. Level 1 is assumed and always the original "
"file. Level 2 is will have each tile represent 4 of the original. So for "
"example if you have a folder of 5000x5000 pixel image files that you chose "
"to chunk 125x125, for each image file your base table will have (5000*5000)/"
"(125*125) records = 1600, your (l=2) <varname>o_2</varname> table will have "
"ceiling(1600/Power(2,2)) = 400 rows, your (l=3) <varname>o_3</varname> will "
"have ceiling(1600/Power(2,3) ) = 200 rows. If your pixels aren't divisible "
"by the size of your tiles, you'll get some scrap tiles (tiles not completely "
"filled). Note that each overview tile generated by raster2pgsql has the same "
"number of pixels as its parent, but is of a lower resolution where each "
"pixel of it represents (Power(2,overview_factor) pixels of the original)."
msgstr ""
"<varname>Overview_factor</varname> - 这是概述表的金字塔级别。 数字越大，表的"
"分辨率越低。 raster2pgsql 如果给定图像文件夹，将计算每个图像文件的概述并单独"
"加载。 假定级别为 1，并且始终为原始文件。 2 级是每个图块代表 4 个原始图块。 "
"例如，如果您有一个包含 5000x5000 像素图像文件的文件夹，您选择将其分块为 "
"125x125，则对于每个图像文件，您的基表将有 (5000*5000)/(125*125) 条记录 = "
"1600，您的 (l=2) <varname>o_2 </varname>表将有上限(1600/Power(2,2)) = 400 "
"行，您的 (l=3) <varname>o_3 </varname>将有上限(1600/Power(2,3) ) = 200 行。 "
"如果您的像素不能被图块的大小整除，您将得到一些废图块（未完全填充的图块）。 请"
"注意，raster2pgsql 生成的每个概览图块与其父级图块具有相同数量的像素，但分辨率"
"较低，其中每个像素代表（原始图块的 Power(2,overview_factor) 像素）。"

#. Tag: title
#: using_raster_dataman.xml:520
#, no-c-format
msgid "Building Custom Applications with PostGIS Raster"
msgstr "使用 PostGIS Raster 构建自定义应用程序"

#. Tag: para
#: using_raster_dataman.xml:521
#, no-c-format
msgid ""
"The fact that PostGIS raster provides you with SQL functions to render "
"rasters in known image formats gives you a lot of options for rendering "
"them. For example you can use OpenOffice / LibreOffice for rendering as "
"demonstrated in <link xlink:href=\"http://www.postgresonline.com/journal/"
"archives/244-Rendering-PostGIS-Raster-graphics-with-LibreOffice-Base-Reports."
"html\">Rendering PostGIS Raster graphics with LibreOffice Base Reports</"
"link>. In addition you can use a wide variety of languages as demonstrated "
"in this section."
msgstr ""
"事实上，PostGIS 栅格为您提供了 SQL 函数来以已知图像格式渲染栅格，这为您提供了"
"很多渲染栅格的选项。 例如，您可以使用 OpenOffice / LibreOffice 进行渲染，如 "
"<link xlink:href=\"http://www.postgresonline.com/journal/archives/244-"
"Rendering-PostGIS-Raster-graphics-with-LibreOffice-Base-Reports.html\">使用 "
"LibreOffice 基础报告渲染 PostGIS 栅格图形</link>中所示。 此外，您还可以使用本"
"节中演示的多种语言。"

#. Tag: title
#: using_raster_dataman.xml:524
#, no-c-format
msgid ""
"PHP Example Outputting using ST_AsPNG in concert with other raster functions"
msgstr "PHP 示例使用 ST_AsPNG 与其他栅格函数进行输出"

#. Tag: para
#: using_raster_dataman.xml:525
#, no-c-format
msgid ""
"In this section, we'll demonstrate how to use the PHP PostgreSQL driver and "
"the <xref linkend=\"RT_ST_AsGDALRaster\"/> family of functions to output "
"band 1,2,3 of a raster to a PHP request stream that can then be embedded in "
"an img src html tag."
msgstr ""
"在本节中，我们将演示如何使用 PHP PostgreSQL 驱动程序和 <xref "
"linkend=\"RT_ST_AsGDALRaster\"/>系列函数将栅格的波段 1、2、3 输出到 PHP 请求"
"流，然后将其嵌入到 img src html 标记中。"

#. Tag: para
#: using_raster_dataman.xml:528 using_raster_dataman.xml:540
#, no-c-format
msgid ""
"The sample query demonstrates how to combine a whole bunch of raster "
"functions together to grab all tiles that intersect a particular wgs 84 "
"bounding box and then unions with <xref linkend=\"RT_ST_Union\"/> the "
"intersecting tiles together returning all bands, transforms to user "
"specified projection using <xref linkend=\"RT_ST_Transform\"/>, and then "
"outputs the results as a png using <xref linkend=\"RT_ST_AsPNG\"/>."
msgstr ""
"示例查询演示了如何将一大堆栅格函数组合在一起，以获取与特定 wgs 84 边界框相交"
"的所有图块，然后将相交图块与 <xref linkend=\"RT_ST_Union\"/>联合起来，返回所"
"有波段，使用 <xref linkend=\"RT_ST_Transform\"/>转换为用户指定的投影，然后输"
"出 使用 <xref linkend=\"RT_ST_AsPNG\"/>将结果显示为 png。"

#. Tag: para
#: using_raster_dataman.xml:531
#, no-c-format
msgid ""
"You would call the below using <programlisting>http://mywebserver/"
"test_raster.php?srid=2249</programlisting> to get the raster image in "
"Massachusetts state plane feet."
msgstr ""
"您可以使用<programlisting> http://mywebserver/test_raster.php?srid=2249 </"
"programlisting>调用以下命令来获取马萨诸塞州平面英尺的栅格图像。"

#. Tag: title
#: using_raster_dataman.xml:535
#, no-c-format
msgid ""
"ASP.NET C# Example Outputting using ST_AsPNG in concert with other raster "
"functions"
msgstr "ASP.NET C# 示例使用 ST_AsPNG 与其他栅格函数进行输出"

#. Tag: para
#: using_raster_dataman.xml:536
#, no-c-format
msgid ""
"In this section, we'll demonstrate how to use Npgsql PostgreSQL .NET driver "
"and the <xref linkend=\"RT_ST_AsGDALRaster\"/> family of functions to output "
"band 1,2,3 of a raster to a PHP request stream that can then be embedded in "
"an img src html tag."
msgstr ""
"在本节中，我们将演示如何使用 Npgsql PostgreSQL .NET 驱动程序和<xref "
"linkend=\"RT_ST_AsGDALRaster\"/>系列函数将栅格的波段 1、2、3 输出到 PHP 请求"
"流，然后将其嵌入到 img src html 标记中。"

#. Tag: para
#: using_raster_dataman.xml:539
#, no-c-format
msgid ""
"You will need the npgsql .NET PostgreSQL driver for this exercise which you "
"can get the latest of from <link xlink:href=\"http://npgsql.projects."
"postgresql.org/\">http://npgsql.projects.postgresql.org/</link>. Just "
"download the latest and drop into your ASP.NET bin folder and you'll be good "
"to go."
msgstr ""
"本练习需要 npgsql .NET PostgreSQL 驱动程序，您可以从 <link xlink:"
"href=\"http://npgsql.projects.postgresql.org/\"> http://npgsql.projects."
"postgresql.org/ </link>获取最新的驱动程序。 只需下载最新版本并放入 ASP.NET "
"bin 文件夹中即可开始使用。"

#. Tag: para
#: using_raster_dataman.xml:543
#, no-c-format
msgid ""
"This is same example as <xref linkend=\"RT_PHP_Output\"/> except implemented "
"in C#."
msgstr ""
"该示例与<xref linkend=\"RT_PHP_Output\"/>示例相同，只不过是在 C# 中实现的。"

#. Tag: para
#: using_raster_dataman.xml:544
#, no-c-format
msgid ""
"You would call the below using <programlisting>http://mywebserver/TestRaster."
"ashx?srid=2249</programlisting> to get the raster image in Massachusetts "
"state plane feet."
msgstr ""
"您可以使用<programlisting> http://mywebserver/TestRaster.ashx?srid=2249 </"
"programlisting>调用以下命令来获取马萨诸塞州平面英尺的栅格图像。"

#. Tag: title
#: using_raster_dataman.xml:549
#, no-c-format
msgid "Java console app that outputs raster query as Image file"
msgstr "将栅格查询输出为图像文件的 Java 控制台应用程序"

#. Tag: para
#: using_raster_dataman.xml:550
#, no-c-format
msgid ""
"This is a simple java console app that takes a query that returns one image "
"and outputs to specified file."
msgstr ""
"这是一个简单的 java 控制台应用程序，它接受一个返回一张图像并输出到指定文件的"
"查询。"

#. Tag: para
#: using_raster_dataman.xml:551
#, no-c-format
msgid ""
"You can download the latest PostgreSQL JDBC drivers from <link xlink:"
"href=\"http://jdbc.postgresql.org/download.html\">http://jdbc.postgresql.org/"
"download.html</link>"
msgstr ""
"您可以从 <link xlink:href=\"http://jdbc.postgresql.org/download.html\"> "
"http://jdbc.postgresql.org/download.html </link>下载最新的 PostgreSQL JDBC 驱"
"动程序"

#. Tag: para
#: using_raster_dataman.xml:552
#, no-c-format
msgid "You can compile the following code using a command something like:"
msgstr "您可以使用如下命令编译以下代码："

#. Tag: para
#: using_raster_dataman.xml:554
#, no-c-format
msgid "And call it from the command-line with something like"
msgstr "并使用类似的命令从命令行调用它"

#. Tag: title
#: using_raster_dataman.xml:561
#, no-c-format
msgid "Use PLPython to dump out images via SQL"
msgstr "使用 PLPython 通过 SQL 转储图像"

#. Tag: para
#: using_raster_dataman.xml:562
#, no-c-format
msgid ""
"This is a plpython stored function that creates a file in the server "
"directory for each record. Requires you have plpython installed. Should work "
"fine with both plpythonu and plpython3u."
msgstr ""
"这是一个 plpython 存储函数，它在服务器目录中为每条记录创建一个文件。 需要你安"
"装了 plpython。 应该可以与 plpythonu 和 plpython3u 一起正常工作。"

#. Tag: title
#: using_raster_dataman.xml:568
#, no-c-format
msgid "Outputting Rasters with PSQL"
msgstr "使用 PSQL 输出栅格"

#. Tag: para
#: using_raster_dataman.xml:569
#, no-c-format
msgid ""
"Sadly PSQL doesn't have easy to use built-in functionality for outputting "
"binaries. This is a bit of a hack that piggy backs on PostgreSQL somewhat "
"legacy large object support. To use first launch your psql commandline "
"connected to your database."
msgstr ""
"遗憾的是，PSQL 没有易于使用的内置功能来输出二进制文件。 这是一个有点依赖于 "
"PostgreSQL 遗留的大对象支持的 hack。 要使用，首先启动连接到数据库的 psql 命令"
"行。"

#. Tag: para
#: using_raster_dataman.xml:571
#, no-c-format
msgid ""
"Unlike the python approach, this approach creates the file on your local "
"computer."
msgstr "与 python 方法不同，此方法在本地计算机上创建文件。"
